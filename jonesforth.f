: CONSTANT WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
1 1 - CONSTANT 0
1 1 + CONSTANT 2
2 2 + CONSTANT 4
2 1 + CONSTANT 3
0 1 - CONSTANT -1

: TRUE -1 ;
: FALSE 0 ;
: 1- 1 - ;
: 1+ 1 + ;
: 2- 2 - ;
: 2+ 2 + ;
: 4+ 4 + ;
: 4- 4 - ;
: 2* 1 LSHIFT ;
: 2/ 1 RSHIFT ;
: 4* 2 LSHIFT ;
: 4/ 2 RSHIFT ;
: INVERT -1 XOR ;


: PICK 1+ 4* DSP@ + @ ;
: DROP DSP@ 4+ DSP! ;
: DUP 0 PICK ;
: OVER 1 PICK ;
: 2DROP DROP DROP ;
: 2DUP OVER OVER ;
: 2OVER 3 PICK 3 PICK ;
: 2SWAP >R -ROT R> -ROT ;
: TUCK SWAP OVER ;
: NIP SWAP DROP ;
: +! DUP @ ROT + SWAP ! ;
: -! DUP @ ROT - SWAP ! ;
: / /MOD SWAP DROP ;
: MOD /MOD DROP ;
: NEGATE 0 SWAP - ;

: <> = INVERT ;
: >= < INVERT ;
: <= > INVERT ;
: 0= 0 = ;
: 0<> 0 <> ;
: 0< 0 < ;
: 0> 0 > ;
: 0<= 0 <= ;
: 0>= 0 >= ;
: NOT 0= ;
: RDROP R> DROP ;

: ALLOT HERE @ SWAP HERE +! ;
: CELLS 4* ;
: VARIABLE 1 CELLS ALLOT WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
: VARIABLE: VARIABLE LATEST @ >CFA EXECUTE ! ;
: >DFA >CFA 4+ ;
: IMMEDIATE LATEST @ 4+ C@ F_IMMED OR LATEST @ 4+ C! ;
LATEST @ 4+ C@ F_IMMED OR LATEST @ 4+ C!       

: HIDDEN 4+ DUP C@ F_HIDDEN XOR SWAP C! ;
: +HIDDEN 4+ DUP C@ F_HIDDEN OR SWAP C! ;
: -HIDDEN 4+ DUP C@ F_HIDDEN INVERT AND SWAP C! ;
: CHAR WORD DROP C@ ;
: [COMPILE] IMMEDIATE WORD FIND >CFA , ;
: ~ WORD CREATE DOCOL , LATEST @ HIDDEN ]] ;
: ~ IMMEDIATE LIT EXIT , LATEST @ HIDDEN [COMPILE] [[ ;
CHAR ; LATEST @ 4+ 1+ C!
CHAR : LATEST @ @ 4+ 1+ C!

: HIDE WORD FIND HIDDEN ;
: LITERAL IMMEDIATE ' LIT , , ;
: RECURSE IMMEDIATE LATEST @ >CFA , ;

: IF IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ;
: ELSE IMMEDIATE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ;
: ?DUP DUP IF DUP THEN ;
: UNLESS IMMEDIATE ' NOT , [COMPILE] IF ;
: BEGIN IMMEDIATE HERE @ ;
: UNTIL IMMEDIATE ' 0BRANCH , HERE @ - , ;
: AGAIN IMMEDIATE ' BRANCH , HERE @ - , ;
: WHILE IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: REPEAT IMMEDIATE ' BRANCH , SWAP HERE @ - , DUP HERE @ SWAP - SWAP ! ;
: CASE IMMEDIATE 0 ;
: OF IMMEDIATE ' OVER , ' = , [COMPILE] IF ' DROP , ;
: ENDOF IMMEDIATE [COMPILE] ELSE ;
: ENDCASE IMMEDIATE ' DROP , BEGIN ?DUP WHILE [COMPILE] THEN REPEAT ;

: ':' [[ CHAR : ]] LITERAL ;
: ';' [[ CHAR ; ]] LITERAL ;
: '(' [[ CHAR ( ]] LITERAL ;
: ')' [[ CHAR ) ]] LITERAL ;
: '"' [[ CHAR " ]] LITERAL ;
: 'A' [[ CHAR A ]] LITERAL ;
: 'Z' [[ CHAR Z ]] LITERAL ;
: 'a' [[ CHAR A ]] LITERAL ;
: 'z' [[ CHAR Z ]] LITERAL ;
: '0' [[ CHAR 0 ]] LITERAL ;
: '9' [[ CHAR 9 ]] LITERAL ;
: '-' [[ CHAR - ]] LITERAL ;
: '.' [[ CHAR . ]] LITERAL ;
: '~' [[ CHAR ~ ]] LITERAL ;

: ( IMMEDIATE 1 BEGIN KEY DUP '(' = IF DROP 1+ ELSE ')' = IF 1- THEN THEN DUP 0= UNTIL DROP ;

( parse numbers )
0 VARIABLE TNUM
'A' '9' '0' - 1+ - CONSTANT A10 
: ISDIGIT DUP '0' >= SWAP '9' <= AND ;
: MULBASE  TNUM @ BASE @ * TNUM ! ;
: NEXTCHAR  OVER C@  -ROT 1 - -ROT 1 + -ROT ;
: SKIPCHAR NEXTCHAR DROP ;
: ISALPHA ( c -- ok ) DUP 'A' >= SWAP 'Z' <= AND ;
: ISLOWERALPHA ( c -- ok ) DUP 'a' >= SWAP 'z' <= AND ;
: CHECKBASE ( n -- ok ) DUP BASE @ < IF TNUM +! TRUE ELSE DROP FALSE THEN ;
: CHECKSIGN ( c -- ) OVER C@ '-' = IF SKIPCHAR -1 ELSE 1 THEN -ROT ;
: NUMBER ( addr length -- n e )
    CHECKSIGN
    0 TNUM !           
    BEGIN    
    DUP 0 =
    IF
        1 - FALSE ( stop, string is complete )
    ELSE
        MULBASE                                
        NEXTCHAR        
        DUP ISDIGIT IF '0' - CHECKBASE ELSE 
        DUP ISALPHA IF A10 - CHECKBASE ELSE DROP FALSE THEN THEN
    THEN
    0 = UNTIL
    1 +
    SWAP DROP ( len -- )
    SWAP TNUM @  * 
    SWAP
    ( -- n e )
;

( String handling )
: TELL DUP 0> IF BEGIN SWAP DUP C@ EMIT 1+ SWAP 1- DUP 0<= UNTIL THEN DROP DROP ;
: ALIGNED ( c-addr -- a-addr ) 3 + 3 INVERT AND ;
: ALIGN HERE @ ALIGNED HERE ! ;
: C, HERE @ C! 1 HERE +! ;
: S" IMMEDIATE ( -- addr len )
	STATE @ IF 
		' LITS , HERE @ 0 ,
		BEGIN KEY DUP '"'
                <> WHILE C, REPEAT
		DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN
	ELSE
		HERE @
		BEGIN KEY DUP '"'
                <> WHILE OVER C! 1+ REPEAT
		DROP HERE @ - HERE @ SWAP
	THEN
;
      
: ." IMMEDIATE ( -- )
	STATE @ IF
		[COMPILE] S" ' TELL ,
	ELSE
		BEGIN KEY DUP '"' = IF DROP EXIT THEN EMIT AGAIN
	THEN
;


: DROPALL S0 @ DSP! ;
: ?STACK S0 @ DSP@ <= IF DROPALL ." Stack underflow!"  THEN ;
: COUNT DUP 1+ SWAP C@  ;
: ID. 4+ COUNT F_LENMASK AND BEGIN DUP 0> WHILE SWAP COUNT EMIT SWAP 1- REPEAT 2DROP ;


: INTERPRET    
    WORD  2DUP FIND DUP 0= 
        IF 
        DROP 2DUP NUMBER ( must be a number or invalid token ) 
        0<> IF
            DROP          
            ." Unknown word <" ( unknown ) 
            TELL          
            ." >"                         
            ELSE 
                NIP NIP 
                STATE @ IF ' LIT , , THEN                
            THEN
        ELSE 
            NIP NIP             
            DUP 4+ C@ F_IMMED AND 0<> IF >CFA EXECUTE ELSE             
            >CFA STATE @ IF , ELSE EXECUTE THEN             
            THEN        
        THEN
;

: QUIT R0 RSP! BEGIN ?STACK INTERPRET AGAIN ;

QUIT


( now we are running in our own interpreter )
( and we have numbers as literals! )

( some character constants )
: '\n' 10 ;
: BKSP 8 ;
: NL 10 ;
: '\t' 9 ;
: BL 32 ;
: CR 10 EMIT ;
: SPACE 32 EMIT ; 
: ISSPACE BL = ;
: SPACES ( n -- ) BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
: ZEROS ( n -- ) BEGIN DUP 0> WHILE '0' EMIT 1- REPEAT DROP ;

( line comments )
: \ IMMEDIATE BEGIN KEY '\n' = UNTIL ;


\ standard words
: ON TRUE SWAP ! ;
: OFF FALSE SWAP ! ;
: MAX 2DUP > IF DROP ELSE SWAP DROP THEN ;
: MIN 2DUP <= IF DROP ELSE SWAP DROP THEN ;
: CLIP ( c a b -- c ) ROT MIN MAX ;
: ABS DUP 0< IF NEGATE THEN ;
: WITHIN -ROT OVER <= IF > IF TRUE ELSE FALSE THEN ELSE 2DROP FALSE THEN ;
: ISLETTER DUP ISALPHA SWAP ISLOWERALPHA OR ;
: DEPTH DSP@ S0 @ - 2 RSHIFT ;
: NTHBIT 1 SWAP LSHIFT ;
: NALIGNED ( val n -- val_aligned ) 1 SWAP LSHIFT 1- DUP ROT + SWAP INVERT AND ; 
: NALIGN ( n -- ) HERE @ SWAP NALIGNED HERE ! ;
: BUFFER ALLOT CONSTANT ;
: C++ DUP C@ 1+ SWAP C! ;
: C-- DUP C@ 1- SWAP C! ;
: ++ DUP @ 1+ SWAP ! ;
: -- DUP @ 1- SWAP ! ;
: ->CELL 4 SWAP +! ;
: <-CELL 4 SWAP -! ;
: ->C 1 SWAP +! ;
: <-C 1 SWAP -! ;






\ write out unsigned numbers
64 BUFFER  NUMPAD
63 NUMPAD + CONSTANT TOPPAD
: WRITECHAR TOPPAD C++ TOPPAD TOPPAD C@ - C! ;
: DIGIT DUP 10 >= IF 55 + WRITECHAR ELSE '0' + WRITECHAR THEN ;
: PUSHPAD TOPPAD TOPPAD C@ - TOPPAD C@ ;
: CLEARPAD 0 TOPPAD C! ;
: PDOT CLEARPAD BEGIN BASE @ /MOD SWAP DIGIT DUP 0= UNTIL DROP ;
: UDOT PDOT PUSHPAD ;
: DOT DUP 0< IF NEGATE PDOT '-' WRITECHAR ELSE PDOT THEN PUSHPAD ;
    
\ aligned unsigned
: U.R UDOT ROT OVER - SPACES TELL ;
: U.ZR UDOT ROT OVER - ZEROS TELL ;
: U. UDOT TELL BL EMIT ;

\ signed number output
: .R DOT ROT OVER - SPACES TELL ;
: . DOT TELL BL EMIT ;
: ? @ . ;



\ Base switching 
: # ( b -- n ) BASE @ SWAP BASE ! WORD NUMBER DROP SWAP BASE ! ;
: 16# 16 # ;
: 10# 10 # ;
: 2# 2 # ;
: 8# 8 # ;
: BINARY ( -- ) 2 BASE ! ;
: OCTAL ( -- ) 8 BASE ! ;
: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;




\ binary manipulation
: .BIN BASE @ SWAP BINARY . BASE ! ;
: .HEX BASE @ SWAP HEX . BASE ! ;
: .OCTAL BASE @ SWAP OCTAL . BASE ! ;
: CLEARMASK INVERT AND ;
: SETMASK OR ;
: BITRANGE SWAP DUP -ROT - 1 SWAP LSHIFT 1- SWAP LSHIFT ;
: CLEARBITS BITRANGE CLEARMASK ;
: SETBITS BITRANGE SETMASK ;
: SETBIT NTHBIT OR ;
: CLEARBIT NTHBIT INVERT AND ;



\ Private namespaces
VARIABLE HIDDEN_BLOCK
VARIABLE REVEAL_BLOCK
: +HIDDEN 4+ DUP C@ F_HIDDEN OR SWAP C! ;
: {{ LATEST @ HIDDEN_BLOCK ! 0 REVEAL_BLOCK ! ;
: PUBLIC: LATEST @ REVEAL_BLOCK ! ;
: }} REVEAL_BLOCK @ DUP 0= IF DROP LATEST THEN BEGIN @ DUP +HIDDEN DUP HIDDEN_BLOCK @ = UNTIL DROP ;


\ stack printing
VARIABLE TSP
: +TSP -4 TSP +! ;
: TSP@ TSP @ @ ;
: SETTSP S0 @ 4 - TSP ! ;
: .S SETTSP BEGIN TSP @ DSP@ 4 + >= IF TSP@ . +TSP FALSE ELSE TRUE THEN UNTIL ; 


\ quotations
\ NB: only works in interactive mode: must fix for compile mode!
: [ S" quote" CREATE DOCOL , LATEST @ HIDDEN ]] ;
: ] IMMEDIATE LIT EXIT , [COMPILE] [[ LATEST @ >CFA ;
: QIF IF NIP EXECUTE ELSE DROP EXECUTE THEN ;
: QIFTRUE IF EXECUTE ELSE DROP THEN ;
: QIFFALSE IF DROP ELSE EXECUTE THEN ;
: QWHILE >R BEGIN R> DUP >R EXECUTE INVERT UNTIL R> DROP ; 
: QUNTIL >R BEGIN R> DUP >R EXECUTE UNTIL R> DROP ; 
\ : QTIMES >R 0 DO R> DUP >R EXECUTE LOOP R> DROP ;
\ : ITER >R 0 DO R> DUP >R I EXECUTE LOOP R> DROP ;
\ : ITERD >R >R  BEGIN R> DUP >R EXECUTE  R> R> 1- -ROT >R >R 0= UNTIL R> R> DROP DROP ; 
: QPRESERVE DUP >R @ >R  EXECUTE R> R> SWAP ! ;
: QDIP >R EXECUTE R> ;
: QSIP DUP >R EXECUTE R> ;


\ Original JONESFORTH introspection functions        
: DICT WORD FIND ;
: VALUE ( n -- ) WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
: TO IMMEDIATE ( n -- )
        DICT >DFA 4+
	STATE @ IF ' LIT , , ' ! , ELSE ! THEN
;
: +TO IMMEDIATE
        DICT >DFA 4+
	STATE @ IF ' LIT , , ' +! , ELSE +! THEN
;

: ?HIDDEN 4+ C@ F_HIDDEN AND ;
: ?IMMEDIATE 4+ C@ F_IMMED AND ;
: WORDS LATEST @ BEGIN ?DUP WHILE DUP ?HIDDEN NOT IF DUP ID. SPACE ." 0x" DUP . CR THEN @ REPEAT CR ;
: FORGET DICT DUP @ LATEST ! HERE ! ;
: CFA> LATEST @ BEGIN ?DUP WHILE 2DUP SWAP < IF NIP EXIT THEN @ REPEAT DROP 0 ;
: WORDEXTENTS ( wordptr -- end start )  HERE @ LATEST @
	BEGIN 2 PICK OVER <> WHILE NIP DUP @ REPEAT
	DROP SWAP ;
    
: SEE
	DICT DUP 0= IF ." Word not found" CR EXIT THEN WORDEXTENTS  ':' EMIT SPACE DUP ID. SPACE
	DUP ?IMMEDIATE IF ." IMMEDIATE " THEN
	>DFA BEGIN 2DUP
        > WHILE DUP @ CASE
		' LIT OF 4 + DUP @ . ENDOF
		' LITS OF [[ CHAR S ]] LITERAL EMIT '"' EMIT SPACE
			4 + DUP @ SWAP 4 + SWAP 2DUP TELL '"' EMIT SPACE + ALIGNED 4 -
		ENDOF
		' 0BRANCH OF ." 0BRANCH ( " 4 + DUP @ . ." ) " ENDOF
		' BRANCH OF ." BRANCH ( " 4 + DUP @ . ." ) " ENDOF
		' ' OF [[ CHAR ' ]] LITERAL EMIT SPACE 4 + DUP @ CFA> ID. SPACE ENDOF
		' EXIT OF 2DUP 4 + <> IF ." EXIT " THEN ENDOF
		DUP CFA> ID. SPACE
	ENDCASE 4 + REPEAT
	';' EMIT CR 2DROP
;
: :NONAME 0 0 CREATE HERE @ DOCOL , ]] ;
: ['] IMMEDIATE ' LIT , ;


\ compile a word by expanding it in place
\ : EXPAND IMMEDIATE STATE @ IF HERE 4- @ WORDEXTENTS HERE @ HERE 4- ! BEGIN DUP @ , 4+ 2DUP = UNTIL THEN ;


\ Exception handling
: EXCEPTION-MARKER RDROP 0 ;
: CATCH ( xt -- exn? ) DSP@ 4+ >R ' EXCEPTION-MARKER 4+ >R EXECUTE ;
: THROW ( n -- ) ?DUP IF
	RSP@ BEGIN DUP R0 4-
        < WHILE DUP @ ' EXCEPTION-MARKER 4+
		= IF 4+ RSP! DUP DUP DUP R> 4- SWAP OVER ! DSP! EXIT THEN
	4+ REPEAT DROP
	CASE
		0 1- OF ." ABORTED" CR ENDOF
		." UNCAUGHT THROW " DUP . CR
	ENDCASE QUIT THEN
;
: ABORT ( -- ) 0 1- THROW ;
: PRINT-STACK-TRACE
	RSP@ BEGIN DUP R0 4-
        < WHILE DUP @ CASE
		' EXCEPTION-MARKER 4+ OF ." CATCH ( DSP=" 4+ DUP @ U. ." ) " ENDOF
		DUP CFA> ?DUP IF 2DUP ID. [[ CHAR + ]] LITERAL EMIT SWAP >DFA 4+ - . THEN
	ENDCASE 4+ REPEAT DROP CR
;
: UNUSED ( -- n ) PAD HERE @ - 4/ ;



\ Hex dumping of memory
: BAR [[ CHAR | ]] LITERAL EMIT ; 
: HEX_ADDRESS DUP 8 SWAP U.ZR  ;
: HD DUP C@ 2 SWAP U.ZR 1+ SPACE ;
: HEX_ROW HD HD HD HD HD HD HD HD ;
: CHECK_CHAR DUP 32 < IF DROP '.' THEN DUP 127 > IF DROP '.' THEN ;
: AS DUP C@ CHECK_CHAR EMIT 1+ ; 
: 4AS AS AS AS AS ;
: ASCII_ROW 4AS 4AS 4AS 4AS ;
: DUMP ( addr len -- )
    DUP 4096 > IF DROP 4096 THEN \ limit size of dump
    BASE @ -ROT HEX  \ store old base and switch to hex
    BEGIN        
    SWAP
    HEX_ADDRESS 2 SPACES HEX_ROW SPACE HEX_ROW 2 SPACES 
    16 - ( shift address back 16 bytes ) BAR ASCII_ROW BAR CR
    SWAP
    16 - DUP 0<= UNTIL \ until done
    CR
    2DROP
    BASE !
;



\ Counted loops
32 CELLS ALLOT VARIABLE: LOOPSP
LOOPSP @ CONSTANT LOOPTOP
: >LOOP LOOPSP @ ! LOOPSP ->CELL ;
: LOOP> LOOPSP <-CELL LOOPSP @ @ ; 
: DO IMMEDIATE ' >LOOP , ' >LOOP , [COMPILE] BEGIN ;
: LOOPCHECK LOOP> LOOP> 1+  2DUP =  -ROT >LOOP >LOOP ;
: +LOOPCHECK LOOP> LOOP> ROT + 2DUP <=  -ROT >LOOP >LOOP ;
: LOOPFINISH LOOP> DROP LOOP> DROP ;
: LOOP IMMEDIATE ' LOOPCHECK , [COMPILE] UNTIL ' LOOPFINISH , ;
: +LOOP IMMEDIATE ' +LOOPCHECK , [COMPILE] UNTIL ' LOOPFINISH , ;
: I LOOPTOP @  ;
: J LOOPTOP 8 + @  ;

\ append a character to a string on the stack; must be enough room in the buffer
: SUFFIX 1+ SWAP OVER + ROT SWAP -ROT C! SWAP ;



\ ANSI codes

27 CONSTANT ESC
: '[' [[ CHAR [ ]] LITERAL ;
: 'm' [[ CHAR m ]] LITERAL ;
: '2' [[ CHAR 2 ]] LITERAL ;
: 'J' [[ CHAR j ]] LITERAL ;
: ANSICOLOR ESC EMIT '[' EMIT DOT TELL 'm' EMIT ;
VARIABLE ANSI_FG_SET
VARIABLE ANSI_BG_SET
: ANSI_FG 30 + DUP ANSI_FG_SET ! ANSICOLOR ;
: ANSI_BG 40 + DUP ANSI_BG_SET ! ANSICOLOR ;
: ANSI_ATTR ANSI_BG ANSI_FG ;
0 CONSTANT ANSI_BLACK
1 CONSTANT ANSI_RED
2 CONSTANT ANSI_GREEN
3 CONSTANT ANSI_YELLOW
4 CONSTANT ANSI_BLUE
5 CONSTANT ANSI_MAGENTA
6 CONSTANT ANSI_CYAN
7 CONSTANT ANSI_WHITE
0 CONSTANT ANSI_PLAIN
1 CONSTANT ANSI_BOLD
4 CONSTANT ANSI_UNDERSCORE
5 CONSTANT ANSI_BLINK
7 CONSTANT ANSI_REVERSE
8 CONSTANT ANSI_CONCEALED
: ANSI_CLS ESC EMIT S" [2J" TELL ;
: ANSI_CLRLINE ESC EMIT S" [K" TELL ;
: ANSI_DEFAULT 37 ANSICOLOR 40 ANSICOLOR ;
: ANSI_ERROR ANSI_BLACK ANSI_BG ANSI_RED ANSI_FG ;


\ System functions

\ Timer access

16# 2000B400 CONSTANT TIMER_BASE
TIMER_BASE 16# 8 + CONSTANT TIMER_CTL
TIMER_BASE 16# 20 + CONSTANT TIMER_CNT
16# 00F90000 CONSTANT TIMER_ENABLE
16# 00F90200 CONSTANT TIMER_SET
: TIMER_INIT TIMER_ENABLE TIMER_CTL ! TIMER_SET TIMER_CTL ! ;
: TIMER_READ TIMER_CNT @ ;
: TIMER_WAIT ( usecs -- )
    TIMER_READ +  
    BEGIN
    DUP 
    TIMER_READ <
    UNTIL     
    DROP
;

: TIMER_SECONDS TIMER_READ 1000000 / ;


\ Load a hex block from the stream. Terminate with non-number
16# 100000 CONSTANT UPLOAD_ADDRESS
: HEXLOAD HEX BEGIN DUP WORD NUMBER 0= IF SWAP C! 1+ FALSE ELSE DROP TRUE THEN UNTIL ;
: UPLOAD ." Start hex transfer:" CR HEX UPLOAD_ADDRESS HEXLOAD ." OK: 0x" UPLOAD_ADDRESS - . ." bytes transferred." CR ;
VARIABLE BOOT_ADDRESS
: BOOT UPLOAD_ADDRESS BOOT_ADDRESS ! BOOT_ADDRESS EXECUTE ;

\ quote that works in immediate mode
: QUOTE WORD FIND >CFA ( -- xt ) ;
: BACKPATCH QUOTE QUOTE 4+ ! ;


\ GPIO

16# 20200004 CONSTANT GPFSEL1 
16# 20200008 CONSTANT GPFSEL2 
16# 2020000C CONSTANT GPFSEL3 
16# 20200010 CONSTANT GPFSEL4 

16# 2020001C CONSTANT GPSET0
16# 20200020 CONSTANT GPSET1
16# 20200028 CONSTANT GPCLR0
16# 2020002C CONSTANT GPCLR1


: GPIO_ON DUP 32 > IF 32 - NTHBIT GPSET1 ! ELSE NTHBIT GPSET0 THEN ; 
: GPIO_OFF DUP 32 > IF 32 - NTHBIT GPCLR1 ! ELSE NTHBIT GPCLR0 THEN ;
: GPIO_ENABLE ( gpio -- sel a b ) 10 /MOD 4 * GPFSEL1 + SWAP 3 * DUP 3 + ;

VARIABLE GPIO_RSTART
VARIABLE GPIO_REND
VARIABLE GPIO

: GPIO_OUT GPIO_ENABLE GPIO_REND ! GPIO_RSTART ! GPIO ! GPIO @ @ GPIO_REND @ GPIO_RSTART @ CLEARBITS GPIO_RSTART SETBIT GPIO ! ;
: GPIO_IN GPIO_ENABLE GPIO_REND ! GPIO_RSTART ! GPIO ! GPIO @ @ GPIO_REND @ GPIO_RSTART @ CLEARBITS GPIO ! ;

47 CONSTANT LED_GPIO

: LEDENABLE GPIO_OUT LED_GPIO ;
: LEDON LED_GPIO GPIO_ON ;
: LEDOFF LED_GPIO GPIO_OFF ;

LEDON
\ UART
5 NTHBIT CONSTANT UART_OUTREADY_MASK
1 NTHBIT CONSTANT UART_INREADY_MASK
16# FF CONSTANT 8BITMASK
16# 20200094 CONSTANT GPPUD
16# 20200098 CONSTANT GPPUDCLK0
16# 20215004 CONSTANT AUX_ENABLES
16# 20215040 CONSTANT AUX_IO
16# 20215054 CONSTANT AUX_LSR
16# 20215044 CONSTANT AUX_IER
16# 20215048 CONSTANT AUX_IIR
16# 2021504C CONSTANT AUX_LCR
16# 20215050 CONSTANT AUX_MCR
16# 20215054 CONSTANT AUX_LSR
16# 20215058 CONSTANT AUX_MSR
16# 2021505C CONSTANT AUX_SCRATCH
16# 20215060 CONSTANT AUX_CNTL
16# 20215064 CONSTANT AUX_STAT
16# 20215068 CONSTANT AUX_BAUD
16# C6 CONSTANT IIR_SETTING
: SPIN 0 DO LOOP ; 
: UARTCLEAR 1 AUX_ENABLES ! 0 AUX_IER !  0 AUX_CNTL ! 0 AUX_MCR ! 0 AUX_IER ! IIR_SETTING AUX_IIR ! 270 AUX_BAUD ! ;
: UARTGPIO GPFSEL1 @ 12 15 CLEARMASK 13 SETBIT 15 18 CLEARMASK 16 SETBIT GPFSEL1 ! ;
: UARTCLOCK 0 GPPUD ! 150 SPIN 14 NTHBIT 15 NTHBIT OR GPPUDCLK0 ! 150 SPIN 0 GPPUDCLK0 ! ;
: UARTINIT UARTCLEAR UARTGPIO UARTCLOCK 3 AUX_CNTL ! ;
: UARTOUTREADY AUX_LSR @ UART_OUTREADY_MASK AND 0<> ;
: UARTINREADY AUX_LSR @ UART_INREADY_MASK AND 0<> ;
: UARTRAWPUT AUX_IO ! ;
: UARTPUT BEGIN UARTOUTREADY UNTIL UARTRAWPUT ;
: UARTEMIT DUP NL = IF 13 UARTPUT THEN UARTPUT ;
: UARTRAWKEY AUX_IO @ 8BITMASK AND ;
\ : UARTKEY BEGIN UARTINREADY UNTIL UARTRAWKEY ;
\ UARTINIT





\ allow input redirection by redefining INPUT-STREAM
\ INPUT-STREAM points at a word that retrieves one more character from the input
\ OUTPUT-STREAM points at a word that outputs a single character
VARIABLE INPUT-STREAM QUOTE MEMKEY INPUT-STREAM !
VARIABLE OUTPUT-STREAM QUOTE UARTEMIT OUTPUT-STREAM !
: NKEY INPUT-STREAM @ EXECUTE ; 
: NEMIT OUTPUT-STREAM @ EXECUTE ;
BACKPATCH NKEY KEY
BACKPATCH NEMIT EMIT


\ rewrite WORD to use the new KEY function
: APPEND ( c addr -- ) DUP C++ DUP C@ + C! ;
: DELETE ( addr -- ) DUP C@ 0> IF C-- THEN ;
: CLEARSTR 0 SWAP C! ;
: PUSHSTR DUP C@ SWAP 1+ SWAP ;
: LENSTR C@ ;
: CMP 2DUP = IF 0 ELSE > IF -1 ELSE 1 THEN THEN ;
: CMPCHAR DUP C@ 2 PICK C@ CMP ;
: 3DROP DROP DROP DROP ;
: CMPSTR ( addr1 l1 addr2 l2 -- cmp ) ROT MIN BEGIN -ROT CMPCHAR DUP 0< IF 3DROP -1 EXIT THEN 0> IF 3DROP 1 EXIT THEN 
  ROT DUP 0= SWAP 1- SWAP UNTIL 3DROP 0 ;
: STRCMP PUSHSTR ROT PUSHSTR CMPSTR ;
: TELLSTR PUSHSTR TELL ;
: ISBLANK DUP BL = OVER '\n' = OR OVER '\t' = OR NIP ;
: SKIPSPACE BEGIN KEY DUP ISBLANK NOT UNTIL ;
32 ALLOT CONSTANT WORDBUFFER# 
WORDBUFFER# 1+ CONSTANT WORDBUFFER
: NWORD
  WORDBUFFER# CLEARSTR
  KEY DUP ISBLANK IF DROP SKIPSPACE THEN  
  WORDBUFFER# APPEND  
  BEGIN KEY DUP ISBLANK IF DROP TRUE ELSE WORDBUFFER# APPEND FALSE THEN UNTIL
  WORDBUFFER# PUSHSTR 
;

( backpatch word to actually execute nword )
BACKPATCH NWORD WORD

\ basic linked list/stack
: MK() 2 CELLS ALLOT DUP 4+ 0 ! ( -- listptr[val,ptr] ) ;
: NIL 0 ;
: CONS MK()  DUP -ROT ! DUP ROT SWAP 4+ ! ;
: CDR ( listptr -- listptr ) 4+ @ ;
: CAR ( listptr -- val ) @ ;
: PRINTLIST BEGIN DUP CAR . DUP CDR 0= IF DROP TRUE ELSE CDR FALSE THEN UNTIL ;
: LASTLIST BEGIN DUP CDR 0= IF TRUE ELSE CDR FALSE THEN UNTIL ;
: MAKE_ENDLESS DUP DUP LASTLIST 4+ ! ;

\ 16 CONSTANT HISTORY_LINES
\ VARIABLE HISTORY_PTR 
\ : ALLOCATE_HISTORY_LINE 256 ALLOT ;
\ 4 CONSTANT HISTORY_LINES
\ HERE @ CONSTANT HISTORY_START ALLOCATE_HISTORY_LINE ALLOCATE_HISTORY_LINE ALLOCATE_HISTORY_LINE ALLOCATE_HISTORY_LINE
\ make loop here
\ : NEXT_HISTORY HISTORY_PTR 1+ DUP > HISTORY_LINES IF 0 THEN HISTORY_PTR ! ;
\ : PREV_HISTORY HISTORY_PTR 1- DUP < 0 IF HISTORY_LINES 1- THEN HISTORY_PTR ! ;
\ : HISTORY_BUF HISTORY_PTR @ 8 LSHIFT HISTORY_START +
\ : COPY_HISTORY HISTORY_BUF TIB# 256 CMOVE ;
\ : PUSH_HISTORY TIB# HISTORY_BUF 256 CMOVE ;


256 BUFFER TIB#
TIB# 1+ CONSTANT TIB
VARIABLE TIB_CURSOR 
VARIABLE ESCAPE_STATE 
0 ESCAPE_STATE !

VARIABLE >IN 0 >IN !
: CLEAR_TIB 0 TIB# C! 0 TIB_CURSOR ! 0 >IN ! ; 
: ECHO UARTKEY DUP EMIT ;
: CURSOR_LEFT TIB_CURSOR C-- ;
: CURSOR_RIGHT TIB_CURSOR C++ ;
: BACKSPACE TIB# C@ 0> IF TIB# C-- CURSOR_LEFT ELSE 0 TIB# C! THEN ;
: WRITE_CHAR TIB# APPEND CURSOR_RIGHT ;

: NORMAL_CHAR DUP CASE 
    ( not in an escape sequence )
    BKSP OF EMIT BACKSPACE ENDOF 
    ESC OF DROP 1 ESCAPE_STATE !  ENDOF    
    ( -- default ) DUP EMIT WRITE_CHAR 
    ENDCASE ;

\ control characters are of the form  'ESC' '[' [value[;value]] <char>
    
\ buffer for ansi value field    
32 BUFFER ESCAPE_BUF



VARIABLE TABPTR
: RESET_TAB LATEST @ TABPTR ! ;
\ find first space character, moving rightwards
: FIND_PREFIX TIB# C@ 1+ BEGIN 1- DUP TIB# + 1+ C@ ISBLANK OVER 0<= OR UNTIL DUP TIB# + SWAP TIB# C@ SWAP - ;
: HANDLE_CURSOR 'A' = IF 'A' CURSOR_LEFT ESC EMIT '[' EMIT 'A' EMIT ELSE DROP THEN ;
: CLEAR_ESCAPE 0 ESCAPE_STATE ! ;
: TEST_ESCAPE DUP '[' = IF 2 ESCAPE_STATE ! ESCAPE_BUF CLEARSTR DROP ELSE CLEAR_ESCAPE NORMAL_CHAR THEN ;
: ANSI_ESCAPE DUP ISLETTER OVER '~' = OR  IF HANDLE_CURSOR CLEAR_ESCAPE ELSE ESCAPE_BUF APPEND THEN ;
: ESCAPE_CHAR ESCAPE_STATE @ 2 = IF ANSI_ESCAPE ELSE TEST_ESCAPE THEN ;  
               
: IN_CHAR ESCAPE_STATE @ 0= IF NORMAL_CHAR ELSE ESCAPE_CHAR THEN ;
: ACCEPT CLEAR_TIB BEGIN UARTKEY DUP IN_CHAR OVER = UNTIL DROP ;
: READ_LINE NL ACCEPT ;

: CHARAT ( addr ix -- c) + 1+ C@ ;

( make line buffered input the outer interpreter )
: LINE_KEY
    ( get some characters )
    TIB# LENSTR 0=  IF BEGIN READ_LINE TIB# LENSTR 0<> UNTIL 0 >IN ! THEN
    TIB# >IN @ CHARAT >IN @ 1+ >IN !
    ( clear buffer at end of line )
    >IN @ TIB# LENSTR >= IF CLEAR_TIB THEN 
;


\ left, right
\ home, end
\ ins/over
\ up/down buffer
\ tab completion


: WELCOME ANSI_BLUE ANSI_BG ANSI_CLS ANSI_YELLOW ANSI_FG
S"                                                      
                       ____    _____   ____    ______  __  __
            __        /\  _`\ /\  __`\/\  _`\ /\__  _\/\ \/\ \
   ___ ___ /\_\    ___\ \ \L\_\ \ \/\ \ \ \L\ \/_/\ \/\ \ \_\ \
 /' __` __`\/\ \ /' _ `\ \  _\/\ \ \ \ \ \ ,  /  \ \ \ \ \  _  \
 /\ \/\ \/\ \ \ \/\ \/\ \ \ \/  \ \ \_\ \ \ \\ \  \ \ \ \ \ \ \ \
 \ \_\ \_\ \_\ \_\ \_\ \_\ \_\   \ \_____\ \_\ \_\ \ \_\ \ \_\ \_\
  \/_/\/_/\/_/\/_/\/_/\/_/\/_/    \/_____/\/_/\/ /  \/_/  \/_/\/_/
" TELL CR
." 0x" UNUSED . ." CELLS FREE" 8 SPACES HEX ." RSP:0x" RSP@ . 4 SPACES ." DSP:0x" DSP@ . 4 SPACES ." S0: 0x" S0 @ . 
CR ." READY"
CR
DECIMAL
;







    
\ experimental stuff

( signed division )


\ heap manipulation
\ | SIZE | PREV | NEXT | REFC | TYPE |
: H->SIZE 0 ;
: H->PREV 4 + ;
: H->NEXT 8 +  ;
: H->REFC 12 + ;
: H->TYPE 16 +  ;

20 CONSTANT HEADER_SIZE
PAD 128 + CONSTANT HEAP_START
16# 1000000 CONSTANT HEAP_SIZE
HEAP_SIZE VARIABLE: HEAP_AVAILABLE
: !-> SWAP DUP -ROT ! 4+ ; 
: INIT_HEAP HEAP_START HEAP_SIZE !-> 0 !-> 0 !-> 0 !-> 0 !-> DROP ;
: BLOCKFITS DUP H->TYPE @ 0= OVER H->SIZE @ > AND ;
: BLOCKNEXT DUP H->NEXT @ 0= IF ." Memory exhausted" ABORT THEN ;
\ : NEWBLOCK ( n ptr -- ) OVER HEADER_SIZE + SIZE @ !-> PREV @ !-> NEXT @ 0 !-> 0 !-> ;
\ : FINDFREE ( n -- ptr ) HEAP_START BLOCKFITS NOT IF BEGIN BLOCKNEXT BLOCKFITS UNTIL  ;
: FREE ( ptr -- ) ;
: REALLOC ( n -- ptr ) ;

: S/MOD 
TUCK DUP 0<
IF NEGATE TRUE ELSE FALSE THEN 
ROT
DUP 0< IF NEGATE -ROT INVERT ELSE -ROT THEN -ROT /MOD ROT
IF NEGATE 1- SWAP ROT SWAP - ELSE ROT DROP THEN ;





: LOOPTEST 5 0 DO I . LOOP ;
: IJLOOPTEST 5 0 DO 10 0 DO I . J . LOOP LOOP ;
: +LOOPTEST 50 0 DO I . 5 +LOOP ;


\ Framebuffer access (preliminary)
: MKSTRUCT  HERE @ CONSTANT ;
: DW 1 CELLS ALLOT CONSTANT ;

4 NALIGN
MKSTRUCT FRAMEBUFFER
DW FB_PHYSICAL_WIDTH
DW FB_PHYSICAL_HEIGHT
DW FB_VIRTUAL_WIDTH
DW FB_VIRTUAL_HEIGHT
DW FB_PITCH
DW FB_BIT_DEPTH
DW FB_X
DW FB_Y
DW FB_PTR
DW FB_SIZE

30 NTHBIT CONSTANT BIT30

16# 2000B880 CONSTANT MAILREAD_ADDR
16# 2000B890 CONSTANT MAILPOLL_ADDR
16# 2000B894 CONSTANT MAILSENDER_ADDR
16# 2000B898 CONSTANT MAILSTATUS_ADDR
16# 2000B89C CONSTANT MAILCONFIG_ADDR
16# 2000B89C CONSTANT MAILWRITE_ADDR

: MAILWAIT_STATUS BEGIN MAILSTATUS_ADDR @ BIT30 AND 0= UNTIL ; 
: LOW4BITS 2# 1111 AND ;
: MAILREAD ( mbox ) LOW4BITS BEGIN MAILWAIT_STATUS DUP MAILREAD_ADDR @ XOR DUP LOW4BITS 0= UNTIL 4 RSHIFT ;
: MAILWRITE ( msg mbox -- ) MAILWAIT_STATUS SWAP 4 LSHIFT OR MAILWRITE_ADDR ! ;

: MAPCHAR NEXTCHAR 3 PICK EXECUTE ROT DUP -ROT 1- C! SWAP ( xt addr len -- xt addr+1 len-1 ) ; 
: MAPSTR 2 PICK 2 PICK BEGIN MAPCHAR DUP 0= UNTIL DROP DROP DROP ( addr len xt -- addr len ) ;
: +13 13 + ;
: ROT13 QUOTE +13 MAPSTR ;

( N D Q R )
VARIABLE DIVD
VARIABLE DIVN

: DIVSTEP RSHIFT DIVN @  1 AND OR DUP 4 PICK >= IF 2 PICK - SWAP 1 OR SWAP THEN ;
: DIVI 
    DIVN ! DIVD !
    DIVD @ 0= IF ." Divide by zero" ABORT THEN
    0 0
    
    DIVSTEP   
;

\ redirect input

WELCOME
CLEAR_TIB
\ Everything after this line will not be seen!
LEDOFF
QUOTE LINE_KEY INPUT-STREAM !



\ ARM opcodes
\ : BIN-> BASE @ BINARY WORD NUMBER CONSTANT BASE ! ;

\ 0 VARIABLE OPC
\ : ENUM 0 OPC ! BEGIN OPC @ CONSTANT OPC 1 +! 1- 0= UNTIL ;
\ 16 ENUM EQ NE CS CC MI PL VS VC HI LS GE LT GT LE AL UNC
\ data processing opcodes
\ 16 ENUM AND EOR SUB RSB ADD ADC SBC RSC TST TEQ CMP CMN ORR MOV BIC MVN 

\ BIN-> 1010 B 
\ BIN-> 1011 BL 





\ TODO
\ xmodem transfer
\ signed division
\ locals
\ color change on : 
\ line editor
\ make quotations work in compile mode
\ rewrite UART in forth
\ private namespaces
\ ?do / +LOOP / LEAVE / UNLOOP
\ alloc / free / resize
\ inline / code
\ fixed point: */ .FX / SIN.COS / SQRT / EXP
\ toupper / tolower
\ struct
\ clear / cmove / fill / blank
\ strcompare
\ make word names indirect : | FLAGS | STRPTR | CFA | | CODE ...
\ inline / unthread / unthread-fully / denext

\ namespaces
\ fix i/o streams
\ some string handling
\ structs, lists



