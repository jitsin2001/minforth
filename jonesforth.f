: CONSTANT WORD CREATE DOCOL , ' ' , , ' EXIT , ;
1 1 - CONSTANT 0
1 1 + CONSTANT 2
2 2 + CONSTANT 4
2 1 + CONSTANT 3
0 1 - CONSTANT -1


: TRUE -1 ;
: FALSE 0 ;
: 1- 1 - ;
: 1+ 1 + ;
: 2- 2 - ;
: 2+ 2 + ;
: 4+ 4 + ;
: 4- 4 - ;
: 2* 1 << ;
: 2/ 1 >> ;
: 4* 2 << ;
: 4/ 2 >> ;
: INVERT -1 XOR ;

: PICK 1+ 4* DSP@ + @ ;
: DROP DSP@ 4+ DSP! ;
: DUP 0 PICK ;
: OVER 1 PICK ;
: SWAP OVER >R >R DROP <R <R ;
: 2DROP DROP DROP ;
: 2DUP OVER OVER ;
: NIP SWAP DROP ;
: -ROT SWAP >R SWAP R> ;
: ROT 2 PICK >R >R >R DROP R> R> R> ;
: +! DUP @ ROT + SWAP ! ;
: -! DUP @ ROT - SWAP ! ;

: NEGATE 0 SWAP - ;
: <> = INVERT ;
: >= < INVERT ;
: <= > INVERT ;
: 0= 0 = ;
: 0<> 0 <> ;
: 0< 0 < ;
: 0> 0 > ;
: 0<= 0 <= ;
: 0>= 0 >= ;
: NOT 0= ;

: ALLOT HERE @ SWAP HERE +! ;
: CELLS 4* ;
: VARIABLE 1 CELLS ALLOT WORD CREATE DOCOL , ' ' , , ' EXIT , ;

4 >> >> >> CONSTANT F_HIDDEN
F_HIDDEN 1 - CONSTANT F_LENMASK
F_HIDDEN >> >> CONSTANT F_IMMED

: IMMEDIATE LATEST @ 4+ C@ F_IMMED OR LATEST @ 4+ C! ;
LATEST @ 4+ C@ F_IMMED OR LATEST @ 4+ C!       


: HIDDEN 4+ DUP C@ F_HIDDEN XOR SWAP C! ;
: +HIDDEN 4+ DUP C@ F_HIDDEN OR SWAP C! ;
: -HIDDEN 4+ DUP C@ F_HIDDEN INVERT AND SWAP C! ;
: CHAR WORD DROP C@ ;
: [COMPILE] IMMEDIATE WORD FIND >CFA , ;
: ~ WORD CREATE DOCOL , LATEST @ HIDDEN ]] ;
: ~ IMMEDIATE ' EXIT , LATEST @ HIDDEN [COMPILE] [[ ;
CHAR ; LATEST @ 4+ 1+ C!
CHAR : LATEST @ @ 4+ 1+ C!

: IF IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ;
: ELSE IMMEDIATE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ;
: ?DUP DUP IF DUP THEN ;
: UNLESS IMMEDIATE ' NOT , [COMPILE] IF ;
: BEGIN IMMEDIATE HERE @ ;
: UNTIL IMMEDIATE ' 0BRANCH , HERE @ - , ;
: AGAIN IMMEDIATE ' BRANCH , HERE @ - , ;
: WHILE IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: REPEAT IMMEDIATE ' BRANCH , SWAP HERE @ - , DUP HERE @ SWAP - SWAP ! ;
: CASE IMMEDIATE 0 ;
: OF IMMEDIATE ' OVER , ' = , [COMPILE] IF ' DROP , ;
: ENDOF IMMEDIATE [COMPILE] ELSE ;
: ENDCASE IMMEDIATE ' DROP , BEGIN ?DUP WHILE [COMPILE] THEN REPEAT ;



: LITERAL IMMEDIATE ' ' , , ;
: ':' [[ CHAR : ]] LITERAL ;
: ';' [[ CHAR ; ]] LITERAL ;
: '(' [[ CHAR ( ]] LITERAL ;
: ')' [[ CHAR ) ]] LITERAL ;
: '"' [[ CHAR " ]] LITERAL ;
: 'A' [[ CHAR A ]] LITERAL ;
: 'Z' [[ CHAR Z ]] LITERAL ;
: 'a' [[ CHAR A ]] LITERAL ;
: 'z' [[ CHAR Z ]] LITERAL ;
: '0' [[ CHAR 0 ]] LITERAL ;
: '9' [[ CHAR 9 ]] LITERAL ;
: '-' [[ CHAR - ]] LITERAL ;
: '.' [[ CHAR . ]] LITERAL ;

: ( IMMEDIATE 1 BEGIN KEY DUP '(' = IF DROP 1+ ELSE ')' = IF 1- THEN THEN DUP 0= UNTIL DROP ;
( comments are now available! )


( MUST IMPLEMENT  /MOD )

: /MOD DIVSRC DIVSUB ;
: / /MOD DROP ; 
: MOD /MOD SWAP DROP ; 
 
( parse numbers )
0 VARIABLE TNUM

( define the BASE variable )
0 4+ 4+ 2+ CONSTANT 10
10 VARIABLE BASE


'A' '9' '0' - 1+ - CONSTANT A10 
: ISDIGIT DUP '0' >= SWAP '9' <= AND ;
: MULBASE  TNUM @ BASE @ * TNUM ! ;
: NEXTCHAR  OVER C@  -ROT 1 - -ROT 1 + -ROT ;
: SKIPCHAR NEXTCHAR DROP ;
: ISALPHA ( c -- ok ) DUP 'A' >= SWAP 'Z' <= AND ;

: CHECKBASE ( n -- ok ) DUP BASE @ < IF TNUM +! TRUE ELSE DROP FALSE THEN ;
: CHECKSIGN ( c -- ) OVER C@ '-' = IF SKIPCHAR -1 ELSE 1 THEN -ROT ;
: NUMBER ( addr length -- n e )
    CHECKSIGN 0 TNUM !           
    BEGIN DUP 0 = IF 1 - FALSE ( stop, string is complete )
    ELSE
        MULBASE NEXTCHAR        
        DUP ISDIGIT IF '0' - CHECKBASE ELSE 
        DUP ISALPHA IF A10 - CHECKBASE ELSE DROP FALSE THEN THEN
    THEN 0 = UNTIL 1 +
    SWAP DROP ( len -- )
    SWAP TNUM @  * 
    SWAP
    ( -- n e ) ;

( String handling )

( note that emit is backpatched later! )
: EMIT EXIT EXIT ;
: TELL DUP 0> IF BEGIN SWAP DUP C@ EMIT 1+ SWAP 1- DUP 0<= UNTIL THEN DROP DROP ;
: ALIGNED ( c-addr -- a-addr ) 3 + 3 INVERT AND ;
: ALIGN HERE @ ALIGNED HERE ! ;
: C, HERE @ C! 1 HERE +! ;


: S" IMMEDIATE ( -- addr len )
	STATE @ IF 
		' LITS , HERE @ 0 ,
		BEGIN KEY DUP '"'
                <> WHILE C, REPEAT
		DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN
	ELSE
		HERE @
		BEGIN KEY DUP '"'
                <> WHILE OVER C! 1+ REPEAT
		DROP HERE @ - HERE @ SWAP
	THEN
;
      
: DROPALL S0 @ DSP! ;
: ?STACK S0 @ DSP@ <= IF DROPALL S" Stack underflow!" TELL THEN ;

: INTERPRET    
    2DUP FIND DUP 0= IF 
        DROP 2DUP NUMBER ( must be a number or invalid token ) 
        0<> IF DROP S" Unknown word <" TELL TELL S" >
" TELL
            ELSE NIP NIP STATE @ IF ' ' , , THEN                
            THEN
        ELSE 
            NIP NIP             
            DUP 4+ C@ F_IMMED AND 0<> IF >CFA EXECUTE ELSE             
            >CFA STATE @ IF , ELSE EXECUTE THEN             
            THEN        
        THEN ;

: QUIT BEGIN R0 RSP! ?STACK WORD INTERPRET AGAIN ;
: BREAK DROPALL ." <BREAK>" CR QUIT ;

QUIT
( now we are running in our own interpreter )
( and we have numbers as literals! )

( version number )
8 CONSTANT VERSION

( line comments )
: '\n' 10 ;
: \ IMMEDIATE BEGIN KEY '\n' = UNTIL ;

\ now create some shorthands for base switching
: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;

\ binary manipulation
: NTHBIT 1 SWAP << ;
: CLEARMASK INVERT AND ;
: SETMASK OR ;
: BITRANGE SWAP DUP -ROT - 1 SWAP << 1- SWAP << ;
: CLEARBITS BITRANGE CLEARMASK ;
: SETBITS BITRANGE SETMASK ;
: SETBIT NTHBIT OR ;
: CLEARBIT NTHBIT INVERT AND ;
HEX
FF CONSTANT 8BITMASK
FFFF CONSTANT 16BITMASK
DECIMAL 
: HIGH16 16 >> ;
: LOW16 16BITMASK AND ;
: LSB 8BITMASK AND ;


: ." IMMEDIATE ( -- )
	STATE @ IF
		[COMPILE] S" ' TELL ,
	ELSE
		BEGIN KEY DUP '"' = IF DROP EXIT THEN EMIT AGAIN
	THEN
;

\ Memory words
: C++ DUP C@ 1+ SWAP C! ;
: C-- DUP C@ 1- SWAP C! ;
: ++ DUP @ 1+ SWAP ! ;
: -- DUP @ 1- SWAP ! ;
: ->CELL 4 SWAP +! ;
: <-CELL 4 SWAP -! ;
: ->C 1 SWAP +! ;
: <-C 1 SWAP -! ;

\ Character constants
: BKSP 8 ;
: NL 10 ;
: '\t' 9 ;
: BL 32 ;
: CR 10 EMIT ;
: SPACE 32 EMIT ; 
: ISSPACE BL = ;
: SPACES ( n -- ) BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
: ZEROS ( n -- ) BEGIN DUP 0> WHILE '0' EMIT 1- REPEAT DROP ;


\ write out unsigned numbers
64 BUFFER  NUMPAD
63 NUMPAD + CONSTANT TOPPAD
: WRITECHAR TOPPAD C++ TOPPAD TOPPAD C@ - C! ;
: DIGIT DUP 10 >= IF 55 + WRITECHAR ELSE '0' + WRITECHAR THEN ;
: PUSHPAD TOPPAD TOPPAD C@ - TOPPAD C@ ;
: CLEARPAD 0 TOPPAD C! ;
: PDOT CLEARPAD BEGIN BASE @ /MOD SWAP DIGIT DUP 0= UNTIL DROP ;
: UDOT PDOT PUSHPAD ;
: DOT DUP 0< IF NEGATE PDOT '-' WRITECHAR ELSE PDOT THEN PUSHPAD ;
    
\ aligned unsigned
: U.R UDOT ROT OVER - SPACES TELL ;
: U.ZR UDOT ROT OVER - ZEROS TELL ;
: U. UDOT TELL BL EMIT ;

\ signed number output
: .R DOT ROT OVER - SPACES TELL ;
: . DOT TELL BL EMIT ;
: ? @ . ;
: .BIN BASE @ SWAP BINARY . BASE ! ;
: .HEX BASE @ SWAP HEX . BASE ! ;
: .OCTAL BASE @ SWAP OCTAL . BASE ! ;

\ Fixed point
: .INTEGER 16 >> DOT TELL  ;
: .FRACTIONAL 16BITMASK AND BEGIN 10 * DUP 16 >> '0' + EMIT 16BITMASK AND DUP 0= UNTIL ;
: .X DUP .INTEGER '.' EMIT .FRACTIONAL ;

\ Base switching words
: # ( b -- n ) BASE @ SWAP BASE ! WORD NUMBER DROP SWAP BASE ! ;
: 16# 16 # ;
: 10# 10 # ;
: 2# 2 # ;
: 8# 8 # ;
: BINARY ( -- ) 2 BASE ! ;
: OCTAL ( -- ) 8 BASE ! ;

\ standard words
: ON TRUE SWAP ! ;
: OFF FALSE SWAP ! ;
: MAX 2DUP > IF DROP ELSE SWAP DROP THEN ;
: MIN 2DUP <= IF DROP ELSE SWAP DROP THEN ;
: CLIP ( c a b -- c ) ROT MIN MAX ;
: ABS DUP 0< IF NEGATE THEN ;
: WITHIN -ROT OVER <= IF > IF TRUE ELSE FALSE THEN ELSE 2DROP FALSE THEN ;
: ISLOWERALPHA ( c -- ok ) DUP 'a' >= SWAP 'z' <= AND ;
: ISLETTER DUP ISALPHA SWAP ISLOWERALPHA OR ;
: DEPTH DSP@ S0 @ - 2 >> ;
: NALIGNED ( val n -- val_aligned ) 1 SWAP << 1- DUP ROT + SWAP INVERT AND ; 
: NALIGN ( n -- ) HERE @ SWAP NALIGNED HERE ! ;
: BUFFER ALLOT CONSTANT ;
: 2OVER 3 PICK 3 PICK ;
: 2SWAP >R -ROT R> -ROT ;
: TUCK SWAP OVER ;
: VARIABLE: VARIABLE LATEST @ >CFA EXECUTE ! ;
: RECURSE IMMEDIATE LATEST @ >CFA , ;

\ Private namespaces
VARIABLE HIDDEN_BLOCK
VARIABLE REVEAL_BLOCK
: +HIDDEN 4+ DUP C@ F_HIDDEN OR SWAP C! ;
: {{ LATEST @ HIDDEN_BLOCK ! 0 REVEAL_BLOCK ! ;
: PUBLIC: LATEST @ REVEAL_BLOCK ! ;
: }} REVEAL_BLOCK @ DUP 0= IF DROP LATEST THEN BEGIN @ DUP +HIDDEN DUP HIDDEN_BLOCK @ = UNTIL DROP ;


\ stack printing
{{
    VARIABLE TSP
    : +TSP -4 TSP +! ;
    : TSP@ TSP @ @ ;
    : SETTSP S0 @ 4 - TSP ! ;
PUBLIC:
    : .S SETTSP BEGIN TSP @ DSP@ 4 + >= IF TSP@ . +TSP FALSE ELSE TRUE THEN UNTIL ; 
    : .R RSP@ BEGIN DUP R0 <= IF ." 0x" DUP @ .HEX 4+ FALSE ELSE TRUE THEN UNTIL DROP ;
}}




\ Original JONESFORTH introspection functions        
: COUNT DUP 1+ SWAP C@  ;
: ID. 4+ COUNT F_LENMASK AND BEGIN DUP 0> WHILE SWAP COUNT EMIT SWAP 1- REPEAT 2DROP ;
: >DFA >CFA 4+ ;
: DICT WORD FIND ;
: VALUE ( n -- ) WORD CREATE DOCOL , ' ' , , ' EXIT , ;
: TO IMMEDIATE ( n -- )
        DICT >DFA 4+
	STATE @ IF ' ' , , ' ! , ELSE ! THEN
;
: +TO IMMEDIATE
        DICT >DFA 4+
	STATE @ IF ' ' , , ' +! , ELSE +! THEN
;

: ?HIDDEN 4+ C@ F_HIDDEN AND ;
: ?IMMEDIATE 4+ C@ F_IMMED AND ;
: WORDS LATEST @ BEGIN ?DUP WHILE DUP ?HIDDEN NOT IF DUP ID. SPACE ." 0x" DUP . CR THEN @ REPEAT CR ;
: FORGET DICT DUP @ LATEST ! HERE ! ;
: CFA> LATEST @ BEGIN ?DUP WHILE 2DUP SWAP < IF NIP EXIT THEN @ REPEAT DROP 0 ;
: WORDEXTENTS ( wordptr -- end start )  HERE @ LATEST @
	BEGIN 2 PICK OVER <> WHILE NIP DUP @ REPEAT
	DROP SWAP ;
    
: SEE
	DICT DUP 0= IF ." Word not found" CR EXIT THEN WORDEXTENTS  ':' EMIT SPACE DUP ID. SPACE
	DUP ?IMMEDIATE IF ." IMMEDIATE " THEN
	>DFA BEGIN 2DUP
        > WHILE DUP @ CASE
		' ' OF 4 + DUP @ . ENDOF
		' LITS OF [[ CHAR S ]] LITERAL EMIT '"' EMIT SPACE
			4 + DUP @ SWAP 4 + SWAP 2DUP TELL '"' EMIT SPACE + ALIGNED 4 -
		ENDOF
		' 0BRANCH OF ." 0BRANCH ( " 4 + DUP @ . ." ) " ENDOF
		' BRANCH OF ." BRANCH ( " 4 + DUP @ . ." ) " ENDOF
		' ' OF [[ CHAR ' ]] LITERAL EMIT SPACE 4 + DUP @ CFA> ID. SPACE ENDOF
		' EXIT OF 2DUP 4 + <> IF ." EXIT " THEN ENDOF
		DUP CFA> ID. SPACE
	ENDCASE 4 + REPEAT
	';' EMIT CR 2DROP
;
: ['] IMMEDIATE ' ' , ;


\ compile a word by expanding it in place
\ : EXPAND IMMEDIATE STATE @ IF HERE 4- @ WORDEXTENTS HERE @ HERE 4- ! BEGIN DUP @ , 4+ 2DUP = UNTIL THEN ;

\ Exception handling
: EXCEPTION-MARKER R> DROP 0 ;
: CATCH ( xt -- exn? ) DSP@ 4+ >R ' EXCEPTION-MARKER 4+ >R EXECUTE ;
: THROW ( n -- ) ?DUP IF
	RSP@ BEGIN DUP R0 4-
        < WHILE DUP @ ' EXCEPTION-MARKER 4+
		= IF 4+ RSP! DUP DUP DUP R> 4- SWAP OVER ! DSP! EXIT THEN
	4+ REPEAT DROP
	CASE
		0 1- OF ." ABORTED" CR ENDOF
		." UNCAUGHT THROW " DUP . CR
	ENDCASE QUIT THEN
;
: ABORT ( -- ) 0 1- THROW ;
: PRINT-STACK-TRACE
	RSP@ BEGIN DUP R0 4-
        < WHILE DUP @ CASE
		' EXCEPTION-MARKER 4+ OF ." CATCH ( DSP=" 4+ DUP @ U. ." ) " ENDOF
		DUP CFA> ?DUP IF 2DUP ID. [[ CHAR + ]] LITERAL EMIT SWAP >DFA 4+ - . THEN
	ENDCASE 4+ REPEAT DROP CR
;
: UNUSED ( -- n ) PAD HERE @ - 4/ ;



\ Hex dumping of memory

{{
    : BAR [[ CHAR | ]] LITERAL EMIT ; 
    : HEX_ADDRESS DUP 8 SWAP U.ZR  ;
    : HD DUP C@ 2 SWAP U.ZR 1+ SPACE ;
    : HEX_ROW HD HD HD HD HD HD HD HD ;
    : PRINTABLE_CHAR DUP 32 < IF DROP '.' THEN DUP 127 > IF DROP '.' THEN ;
    : AS DUP C@ PRINTABLE_CHAR EMIT 1+ ; 
    : 4AS AS AS AS AS ;
    : ASCII_ROW 4AS 4AS 4AS 4AS ;
PUBLIC:
    : DUMP ( addr len -- ) DUP 4096 > IF DROP 4096 THEN 
        BASE @ -ROT HEX  \ store old base and switch to hex
        BEGIN SWAP HEX_ADDRESS 2 SPACES HEX_ROW SPACE HEX_ROW 2 SPACES 
        16 - BAR ASCII_ROW BAR CR SWAP 16 - DUP 0<= UNTIL \ until done
        CR 2DROP BASE ! ;
}}

\ Counted loops
32 CELLS ALLOT VARIABLE: LOOPSP
LOOPSP @ CONSTANT LOOPTOP
: >LOOP LOOPSP @ ! LOOPSP ->CELL ;
: LOOP> LOOPSP <-CELL LOOPSP @ @ ; 
: DO IMMEDIATE ' >LOOP , ' >LOOP , [COMPILE] BEGIN ;
: LOOPCHECK LOOP> LOOP> 1+  2DUP =  -ROT >LOOP >LOOP ;
: +LOOPCHECK LOOP> LOOP> ROT + 2DUP <=  -ROT >LOOP >LOOP ;
: LOOPFINISH LOOP> DROP LOOP> DROP ;
: LOOP IMMEDIATE ' LOOPCHECK , [COMPILE] UNTIL ' LOOPFINISH , ;
: +LOOP IMMEDIATE ' +LOOPCHECK , [COMPILE] UNTIL ' LOOPFINISH , ;
: I LOOPTOP @  ;
: J LOOPTOP 8 + @  ;

\ append a character to a string on the stack; must be enough room in the buffer
: SUFFIX 1+ SWAP OVER + ROT SWAP -ROT C! SWAP ;





\ ANSI codes

27 CONSTANT ESC
: '~' [[ CHAR ~ ]] LITERAL ;
: '[' [[ CHAR [ ]] LITERAL ;
: 'm' [[ CHAR m ]] LITERAL ;
: '2' [[ CHAR 2 ]] LITERAL ;
: 'J' [[ CHAR j ]] LITERAL ;
: ANSICOLOR ESC EMIT '[' EMIT DOT TELL 'm' EMIT ;
VARIABLE ANSI_FG_SET
VARIABLE ANSI_BG_SET
: ANSI_FG 30 + DUP ANSI_FG_SET ! ANSICOLOR ;
: ANSI_BG 40 + DUP ANSI_BG_SET ! ANSICOLOR ;
: ANSI_ATTR ANSI_BG ANSI_FG ;
0 CONSTANT ANSI_BLACK
1 CONSTANT ANSI_RED
2 CONSTANT ANSI_GREEN
3 CONSTANT ANSI_YELLOW
4 CONSTANT ANSI_BLUE
5 CONSTANT ANSI_MAGENTA
6 CONSTANT ANSI_CYAN
7 CONSTANT ANSI_WHITE
0 CONSTANT ANSI_PLAIN
1 CONSTANT ANSI_BOLD
4 CONSTANT ANSI_UNDERSCORE
5 CONSTANT ANSI_BLINK
7 CONSTANT ANSI_REVERSE
8 CONSTANT ANSI_CONCEALED
: ANSI_CLS ESC EMIT S" [2J" TELL ;
: ANSI_CLRLINE ESC EMIT S" [K" TELL ;
: ANSI_DEFAULT 37 ANSICOLOR 40 ANSICOLOR ;
: ANSI_ERROR ANSI_BLACK ANSI_BG ANSI_RED ANSI_FG ;


\ System functions

IOBASE CONSTANT 20000000
: IOCONSTANT IOBASE + WORD CREATE DOCOL , ' ' , , ' EXIT , ;

\ Timer access
{{
    16# B400 IOCONSTANT TIMER_BASE
    TIMER_BASE 16# 8 + CONSTANT TIMER_CTL
    TIMER_BASE 16# 20 + CONSTANT TIMER_CNT
    16# 00F90000 CONSTANT TIMER_ENABLE
    16# 00F90200 CONSTANT TIMER_SET
    0 VARIABLE: WAIT_ADJUSTMENT
    VARIABLE TIMEITVAR
    VARIABLE TIMEIT_OVERHEAD
PUBLIC:    
    : TIMER_INIT TIMER_ENABLE TIMER_CTL ! TIMER_SET TIMER_CTL ! ;
    : TIMER_READ TIMER_CNT @ ;
    : TIMER_WAIT ( usecs -- ) TIMER_READ +  WAIT_ADJUSTMENT @ - BEGIN DUP TIMER_READ < UNTIL DROP ;
    : TIMER_SECONDS TIMER_READ 1000000 / ;    
    \ Profile run time of a word: e.g. 200 30 RUNTIME + 
    \ compute the call overhead 
    : CALC_OVERHEAD TIMER_READ TIMEITVAR ! TIMER_READ TIMEITVAR @ - TIMEIT_OVERHEAD ! ;
    CALC_OVERHEAD FORGET CALC_OVERHEAD
    : RUNTIME WORD FIND >CFA TIMER_READ TIMEITVAR ! EXECUTE TIMER_READ TIMEITVAR @ - TIMEIT_OVERHEAD @ - ;
    \ adjust the timer waiting
    200 RUNTIME TIMER_WAIT 200 - WAIT_ADJUSTMENT !
    : TIMEIT RUNTIME . ." uS" ;
}}


\ GPIO



HEX
200004 IOCONSTANT GPFSEL1 
200008 IOCONSTANT GPFSEL2 
20000C IOCONSTANT GPFSEL3 
200010 IOCONSTANT GPFSEL4 
20001C IOCONSTANT GPSET0
200020 IOCONSTANT GPSET1
200028 IOCONSTANT GPCLR0
20002C IOCONSTANT GPCLR1
DECIMAL

: GPIO_ON DUP 32 > IF 32 - NTHBIT GPSET1 ! ELSE NTHBIT GPSET0 THEN ; 
: GPIO_OFF DUP 32 > IF 32 - NTHBIT GPCLR1 ! ELSE NTHBIT GPCLR0 THEN ;
: GPIO_ENABLE ( gpio -- sel a b ) 10 /MOD 4 * GPFSEL1 + SWAP 3 * DUP 3 + ;

VARIABLE GPIO_RSTART
VARIABLE GPIO_REND
VARIABLE GPIO

: GPIO_OUT GPIO_ENABLE GPIO_REND ! GPIO_RSTART ! GPIO ! GPIO @ @ GPIO_REND @ GPIO_RSTART @ CLEARBITS GPIO_RSTART SETBIT GPIO ! ;
: GPIO_IN GPIO_ENABLE GPIO_REND ! GPIO_RSTART ! GPIO ! GPIO @ @ GPIO_REND @ GPIO_RSTART @ CLEARBITS GPIO ! ;

\ For B+ boards
47 CONSTANT LED_GPIO

: LEDENABLE GPIO_OUT LED_GPIO ;
: LEDON LED_GPIO GPIO_ON ;
: LEDOFF LED_GPIO GPIO_OFF ;
LEDON

\ UART
{{
    5 NTHBIT CONSTANT UART_OUTREADY_MASK
    0 NTHBIT CONSTANT UART_INREADY_MASK

    HEX
    200094 IOCONSTANT GPPUD
    200098 IOCONSTANT GPPUDCLK0
    215004 IOCONSTANT AUX_ENABLES
    215040 IOCONSTANT AUX_IO
    215054 IOCONSTANT AUX_LSR
    215044 IOCONSTANT AUX_IER
    215048 IOCONSTANT AUX_IIR
    21504C IOCONSTANT AUX_LCR
    215050 IOCONSTANT AUX_MCR 
    215058 IOCONSTANT AUX_MSR
    215060 IOCONSTANT AUX_CNTL
    215068 IOCONSTANT AUX_BAUD
    DECIMAL

    : SPIN 0 DO LOOP ; 
    : UARTCLEAR 1 AUX_ENABLES ! 0 AUX_IER !  0 AUX_CNTL ! 3 AUX_LCR ! 0 AUX_MCR ! 0 AUX_IER ! 198 AUX_IIR ! 270 AUX_BAUD ! ;
    : UARTGPIO GPFSEL1 @ 12 15 CLEARBITS 13 SETBIT 15 18 CLEARBITS 16 SETBIT GPFSEL1 ! ;
    : UARTCLOCK 0 GPPUD ! 150 SPIN 14 NTHBIT 15 NTHBIT OR GPPUDCLK0 ! 150 SPIN 0 GPPUDCLK0 ! ;    
    : UARTRAWPUT AUX_IO ! ;
    : UARTPUT BEGIN UARTOUTREADY UNTIL UARTRAWPUT ;    
    : UARTGET AUX_IO @ 8BITMASK AND ;
    : BREAK_TEST 3 = IF BREAK THEN ;
    : UARTRAWKEY BEGIN UARTINREADY UNTIL UARTGET  ;
    
    PUBLIC:
    : UARTOUTREADY AUX_LSR @ UART_OUTREADY_MASK AND 0<> ;
    : UARTINREADY AUX_LSR @ UART_INREADY_MASK AND 0<> ;
    
    : UARTINIT UARTCLEAR UARTGPIO UARTCLOCK 3 AUX_CNTL ! ;
    : UARTEMIT DUP '\n' = IF 13 UARTPUT THEN UARTPUT ;
    : UARTKEY UARTRAWKEY DUP 3 = IF BREAK THEN DUP 13 = IF DROP 10 THEN ;
      
}}
UARTINIT


\ Load a hex block from the stream. Terminate with non-number
{{
    16# 100000 CONSTANT UPLOAD_ADDRESS
    VARIABLE BOOT_ADDRESS
    : HEXLOAD HEX BEGIN DUP WORD NUMBER 0= IF SWAP C! 1+ FALSE ELSE DROP TRUE THEN UNTIL ;
PUBLIC:
    : UPLOAD ." Start hex transfer:" CR HEX UPLOAD_ADDRESS HEXLOAD ." OK: 0x" UPLOAD_ADDRESS - . ." bytes transferred." CR ;
    : BOOT UPLOAD_ADDRESS BOOT_ADDRESS ! BOOT_ADDRESS EXECUTE ;
}}

\ quote that works in immediate mode
: QUOTE WORD FIND >CFA ( -- xt ) ;
: BACKPATCH QUOTE QUOTE 4+ ! ;

: UARTIN_TIMEOUT TIMER_READ + BEGIN UARTINREADY IF UARTGET EXIT ELSE DUP TIMER_READ < IF -1 EXIT THEN THEN AGAIN ;

\ allow input redirection by redefining INPUT-STREAM
\ INPUT-STREAM points at a word that retrieves one more character from the input
\ OUTPUT-STREAM points at a word that outputs a single character
VARIABLE INPUT-STREAM QUOTE MEMKEY INPUT-STREAM !
VARIABLE OUTPUT-STREAM QUOTE UARTEMIT OUTPUT-STREAM !
: NKEY INPUT-STREAM @ EXECUTE ; 
: NEMIT OUTPUT-STREAM @ EXECUTE ;
BACKPATCH NKEY KEY
BACKPATCH NEMIT EMIT

\ rewrite WORD to use the new KEY function
: APPEND ( c addr -- ) DUP C++ DUP C@ + C! ;
: DELETE ( addr -- ) DUP C@ 0> IF C-- THEN ;
: CLEARSTR 0 SWAP C! ;
: PUSHSTR DUP C@ SWAP 1+ SWAP ;
: LENSTR C@ ;
: CMP 2DUP = IF 0 ELSE > IF -1 ELSE 1 THEN THEN ;
: CMPCHAR DUP C@ 2 PICK C@ CMP ;
: 3DROP DROP DROP DROP ;
: CMPSTR ( addr1 l1 addr2 l2 -- cmp ) ROT MIN BEGIN -ROT CMPCHAR DUP 0< IF 3DROP -1 EXIT THEN 0> IF 3DROP 1 EXIT THEN 
  ROT DUP 0= SWAP 1- SWAP UNTIL 3DROP 0 ;
: STRCMP PUSHSTR ROT PUSHSTR CMPSTR ;
: TELLSTR PUSHSTR TELL ;
: ISBLANK DUP BL = OVER '\n' = OR OVER '\t' = OR NIP ;
: SKIPSPACE BEGIN KEY DUP ISBLANK NOT UNTIL ;
32 ALLOT CONSTANT WORDBUFFER# 
WORDBUFFER# 1+ CONSTANT WORDBUFFER
: NWORD
  WORDBUFFER# CLEARSTR
  KEY DUP ISBLANK IF DROP SKIPSPACE THEN  
  WORDBUFFER# APPEND  
  BEGIN KEY DUP ISBLANK IF DROP TRUE ELSE WORDBUFFER# APPEND FALSE THEN UNTIL
  WORDBUFFER# PUSHSTR 
;

( backpatch word to actually execute nword )
BACKPATCH NWORD WORD

256 BUFFER TIB#
TIB# 1+ CONSTANT TIB
VARIABLE TIB_CURSOR 
VARIABLE ESCAPE_STATE 
0 ESCAPE_STATE !

VARIABLE >IN 0 >IN !
: CLEAR_TIB 0 TIB# C! 0 TIB_CURSOR ! 0 >IN ! ; 
: ECHO UARTKEY DUP EMIT ;
: CURSOR_LEFT TIB_CURSOR C-- ;
: CURSOR_RIGHT TIB_CURSOR C++ ;
: BACKSPACE TIB# C@ 0> IF TIB# C-- CURSOR_LEFT ELSE 0 TIB# C! THEN ;
: WRITE_CHAR TIB# APPEND CURSOR_RIGHT ;

: NORMAL_CHAR DUP CASE 
    ( not in an escape sequence )
    BKSP OF EMIT BACKSPACE ENDOF 
    ESC OF DROP 1 ESCAPE_STATE !  ENDOF    
    ( -- default ) DUP EMIT WRITE_CHAR 
    ENDCASE ;

\ control characters are of the form  'ESC' '[' [value[;value]] <char>
    
\ buffer for ansi value field    
32 BUFFER ESCAPE_BUF

VARIABLE TABPTR
: RESET_TAB LATEST @ TABPTR ! ;
\ find first space character, moving rightwards
: FIND_PREFIX TIB# C@ 1+ BEGIN 1- DUP TIB# + 1+ C@ ISBLANK OVER 0<= OR UNTIL DUP TIB# + SWAP TIB# C@ SWAP - ;
: HANDLE_CURSOR 'A' = IF 'A' CURSOR_LEFT ESC EMIT '[' EMIT 'A' EMIT ELSE DROP THEN ;
: CLEAR_ESCAPE 0 ESCAPE_STATE ! ;
: TEST_ESCAPE DUP '[' = IF 2 ESCAPE_STATE ! ESCAPE_BUF CLEARSTR DROP ELSE CLEAR_ESCAPE NORMAL_CHAR THEN ;
: ANSI_ESCAPE DUP ISLETTER OVER '~' = OR  IF HANDLE_CURSOR CLEAR_ESCAPE ELSE ESCAPE_BUF APPEND THEN ;
: ESCAPE_CHAR ESCAPE_STATE @ 2 = IF ANSI_ESCAPE ELSE TEST_ESCAPE THEN ;  
               
: IN_CHAR ESCAPE_STATE @ 0= IF NORMAL_CHAR ELSE ESCAPE_CHAR THEN ;
: ACCEPT CLEAR_TIB BEGIN UARTKEY DUP IN_CHAR OVER = UNTIL DROP ;
: READ_LINE NL ACCEPT ;

: CHARAT ( addr ix -- c) + 1+ C@ ;
: LINE_FLUSH_IN CLEAR_TIB ;




: FLUSH_IN . ; \ backpatch this later
: FLUSH_OUT . ; \ backpatch this later


( make line buffered input the outer interpreter )
: LINE_KEY
    ( get some characters )
    TIB# LENSTR 0=  IF BEGIN READ_LINE TIB# LENSTR 0<> UNTIL 0 >IN ! THEN
    TIB# >IN @ CHARAT >IN @ 1+ >IN !
    ( clear buffer at end of line )
    >IN @ TIB# LENSTR >= IF CLEAR_TIB THEN 
;


: STATUS  ." HERE:0x" HERE @ .HEX  ." LATEST:0x" LATEST @ .HEX  2 SPACES ." R0:0x" R0 .HEX  ." RSP:0x" RSP@ .HEX 2 SPACES ." DSP:0x" DSP@ .HEX  ." S0:0x" S0 @ .HEX  CR ;

: WELCOME ANSI_BLUE ANSI_BG ANSI_CLS ANSI_YELLOW ANSI_FG
S"                                                      
                       ____    _____   ____    ______  __  __
            __        /\  _`\ /\  __`\/\  _`\ /\__  _\/\ \/\ \
   ___ ___ /\_\    ___\ \ \L\_\ \ \/\ \ \ \L\ \/_/\ \/\ \ \_\ \
 /' __` __`\/\ \ /' _ `\ \  _\/\ \ \ \ \ \ ,  /  \ \ \ \ \  _  \
 /\ \/\ \/\ \ \ \/\ \/\ \ \ \/  \ \ \_\ \ \ \\ \  \ \ \ \ \ \ \ \
 \ \_\ \_\ \_\ \_\ \_\ \_\ \_\   \ \_____\ \_\ \_\ \ \_\ \ \_\ \_\
  \/_/\/_/\/_/\/_/\/_/\/_/\/_/    \/_____/\/_/\/ /  \/_/  \/_/\/_/
" TELL CR
." 0x" UNUSED . ." CELLS FREE" 
CR STATUS

CR ." READY"
CR
DECIMAL
;


\ redirect input

CLEAR_TIB LEDOFF WELCOME 
\ Everything after this line will not be seen!
QUOTE LINE_KEY INPUT-STREAM !





