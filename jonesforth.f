: CONSTANT WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
1 1 - CONSTANT 0
1 1 + CONSTANT 2
2 2 + CONSTANT 4
2 1 + CONSTANT 3
0 1 - CONSTANT -1

: TRUE -1 ;
: FALSE 0 ;
: 1- 1 - ;
: 1+ 1 + ;
: 2- 2 - ;
: 2+ 2 + ;
: 4+ 4 + ;
: 4- 4 - ;
: 2* 1 LSHIFT ;
: 2/ 1 RSHIFT ;
: 4* 2 LSHIFT ;
: 4/ 2 RSHIFT ;
: INVERT -1 XOR ;

: PICK 1+ 4* DSP@ + @ ;
: DROP DSP@ 4+ DSP! ;
: DUP 0 PICK ;
: OVER 1 PICK ;
: 2DROP DROP DROP ;
: 2DUP OVER OVER ;
: NIP SWAP DROP ;
: +! DUP @ ROT + SWAP ! ;
: -! DUP @ ROT - SWAP ! ;
: / /MOD SWAP DROP ;
: MOD /MOD DROP ;
: NEGATE 0 SWAP - ;

: <> = INVERT ;
: >= < INVERT ;
: <= > INVERT ;
: 0= 0 = ;
: 0<> 0 <> ;
: 0< 0 < ;
: 0> 0 > ;
: 0<= 0 <= ;
: 0>= 0 >= ;
: NOT 0= ;

: ALLOT HERE @ SWAP HERE +! ;
: CELLS 4* ;
: VARIABLE 1 CELLS ALLOT WORD CREATE DOCOL , ' LIT , , ' EXIT , ;

: IMMEDIATE LATEST @ 4+ C@ F_IMMED OR LATEST @ 4+ C! ;
LATEST @ 4+ C@ F_IMMED OR LATEST @ 4+ C!       

: HIDDEN 4+ DUP C@ F_HIDDEN XOR SWAP C! ;
: +HIDDEN 4+ DUP C@ F_HIDDEN OR SWAP C! ;
: -HIDDEN 4+ DUP C@ F_HIDDEN INVERT AND SWAP C! ;
: CHAR WORD DROP C@ ;
: [COMPILE] IMMEDIATE WORD FIND >CFA , ;
: ~ WORD CREATE DOCOL , LATEST @ HIDDEN ]] ;
: ~ IMMEDIATE LIT EXIT , LATEST @ HIDDEN [COMPILE] [[ ;
CHAR ; LATEST @ 4+ 1+ C!
CHAR : LATEST @ @ 4+ 1+ C!

: IF IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ;
: ELSE IMMEDIATE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ;
: ?DUP DUP IF DUP THEN ;
: UNLESS IMMEDIATE ' NOT , [COMPILE] IF ;
: BEGIN IMMEDIATE HERE @ ;
: UNTIL IMMEDIATE ' 0BRANCH , HERE @ - , ;
: AGAIN IMMEDIATE ' BRANCH , HERE @ - , ;
: WHILE IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: REPEAT IMMEDIATE ' BRANCH , SWAP HERE @ - , DUP HERE @ SWAP - SWAP ! ;
: CASE IMMEDIATE 0 ;
: OF IMMEDIATE ' OVER , ' = , [COMPILE] IF ' DROP , ;
: ENDOF IMMEDIATE [COMPILE] ELSE ;
: ENDCASE IMMEDIATE ' DROP , BEGIN ?DUP WHILE [COMPILE] THEN REPEAT ;

: LITERAL IMMEDIATE ' LIT , , ;
: ':' [[ CHAR : ]] LITERAL ;
: ';' [[ CHAR ; ]] LITERAL ;
: '(' [[ CHAR ( ]] LITERAL ;
: ')' [[ CHAR ) ]] LITERAL ;
: '"' [[ CHAR " ]] LITERAL ;
: 'A' [[ CHAR A ]] LITERAL ;
: 'Z' [[ CHAR Z ]] LITERAL ;
: 'a' [[ CHAR A ]] LITERAL ;
: 'z' [[ CHAR Z ]] LITERAL ;
: '0' [[ CHAR 0 ]] LITERAL ;
: '9' [[ CHAR 9 ]] LITERAL ;
: '-' [[ CHAR - ]] LITERAL ;
: '.' [[ CHAR . ]] LITERAL ;

: ( IMMEDIATE 1 BEGIN KEY DUP '(' = IF DROP 1+ ELSE ')' = IF 1- THEN THEN DUP 0= UNTIL DROP ;
( comments are now available! )


( parse numbers )
0 VARIABLE TNUM
'A' '9' '0' - 1+ - CONSTANT A10 
: ISDIGIT DUP '0' >= SWAP '9' <= AND ;
: MULBASE  TNUM @ BASE @ * TNUM ! ;
: NEXTCHAR  OVER C@  -ROT 1 - -ROT 1 + -ROT ;
: SKIPCHAR NEXTCHAR DROP ;
: ISALPHA ( c -- ok ) DUP 'A' >= SWAP 'Z' <= AND ;

: CHECKBASE ( n -- ok ) DUP BASE @ < IF TNUM +! TRUE ELSE DROP FALSE THEN ;
: CHECKSIGN ( c -- ) OVER C@ '-' = IF SKIPCHAR -1 ELSE 1 THEN -ROT ;
: NUMBER ( addr length -- n e )
    CHECKSIGN 0 TNUM !           
    BEGIN DUP 0 = IF 1 - FALSE ( stop, string is complete )
    ELSE
        MULBASE NEXTCHAR        
        DUP ISDIGIT IF '0' - CHECKBASE ELSE 
        DUP ISALPHA IF A10 - CHECKBASE ELSE DROP FALSE THEN THEN
    THEN 0 = UNTIL 1 +
    SWAP DROP ( len -- )
    SWAP TNUM @  * 
    SWAP
    ( -- n e ) ;

( String handling )
: TELL DUP 0> IF BEGIN SWAP DUP C@ EMIT 1+ SWAP 1- DUP 0<= UNTIL THEN DROP DROP ;
: ALIGNED ( c-addr -- a-addr ) 3 + 3 INVERT AND ;
: ALIGN HERE @ ALIGNED HERE ! ;
: C, HERE @ C! 1 HERE +! ;
: S" IMMEDIATE ( -- addr len )
	STATE @ IF 
		' LITS , HERE @ 0 ,
		BEGIN KEY DUP '"'
                <> WHILE C, REPEAT
		DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN
	ELSE
		HERE @
		BEGIN KEY DUP '"'
                <> WHILE OVER C! 1+ REPEAT
		DROP HERE @ - HERE @ SWAP
	THEN
;
      
: DROPALL S0 @ DSP! ;
: ?STACK S0 @ DSP@ <= IF DROPALL S" Stack underflow!" TELL THEN ;

: INTERPRET    
    2DUP FIND DUP 0= IF 
        DROP 2DUP NUMBER ( must be a number or invalid token ) 
        0<> IF DROP S" Unknown word <" TELL TELL S" >
" TELL
            ELSE NIP NIP STATE @ IF ' LIT , , THEN                
            THEN
        ELSE 
            NIP NIP             
            DUP 4+ C@ F_IMMED AND 0<> IF >CFA EXECUTE ELSE             
            >CFA STATE @ IF , ELSE EXECUTE THEN             
            THEN        
        THEN ;

: QUIT BEGIN R0 RSP! ?STACK WORD INTERPRET AGAIN ;
: BREAK DROPALL ." <BREAK>" CR QUIT ;

QUIT
( now we are running in our own interpreter )
( and we have numbers as literals! )

( line comments )
: '\n' 10 ;
: \ IMMEDIATE BEGIN KEY '\n' = UNTIL ;

: HEX 16 BASE ! ;
: DECIMAL 10 BASE ! ;

\ binary manipulation
: NTHBIT 1 SWAP LSHIFT ;
: CLEARMASK INVERT AND ;
: SETMASK OR ;
: BITRANGE SWAP DUP -ROT - 1 SWAP LSHIFT 1- SWAP LSHIFT ;
: CLEARBITS BITRANGE CLEARMASK ;
: SETBITS BITRANGE SETMASK ;
: SETBIT NTHBIT OR ;
: CLEARBIT NTHBIT INVERT AND ;
HEX
FF CONSTANT 8BITMASK
FFFF CONSTANT 16BITMASK
DECIMAL 
: HIGH16 16 RSHIFT ;
: LOW16 16BITMASK AND ;
: LSB 8BITMASK AND ;

\ GPIO
HEX
20200004 CONSTANT GPFSEL1 
20200008 CONSTANT GPFSEL2 
2020000C CONSTANT GPFSEL3 
20200010 CONSTANT GPFSEL4 
2020001C CONSTANT GPSET0
20200020 CONSTANT GPSET1
20200028 CONSTANT GPCLR0
2020002C CONSTANT GPCLR1
DECIMAL

: GPIO_ON DUP 32 > IF 32 - NTHBIT GPSET1 ! ELSE NTHBIT GPSET0 THEN ; 
: GPIO_OFF DUP 32 > IF 32 - NTHBIT GPCLR1 ! ELSE NTHBIT GPCLR0 THEN ;
: GPIO_ENABLE ( gpio -- sel a b ) 10 /MOD 4 * GPFSEL1 + SWAP 3 * DUP 3 + ;

VARIABLE GPIO_RSTART
VARIABLE GPIO_REND
VARIABLE GPIO

: GPIO_OUT GPIO_ENABLE GPIO_REND ! GPIO_RSTART ! GPIO ! GPIO @ @ GPIO_REND @ GPIO_RSTART @ CLEARBITS GPIO_RSTART SETBIT GPIO ! ;
: GPIO_IN GPIO_ENABLE GPIO_REND ! GPIO_RSTART ! GPIO ! GPIO @ @ GPIO_REND @ GPIO_RSTART @ CLEARBITS GPIO ! ;

\ For B+ boards
47 CONSTANT LED_GPIO

: LEDENABLE GPIO_OUT LED_GPIO ;
: LEDON LED_GPIO GPIO_ON ;
: LEDOFF LED_GPIO GPIO_OFF ;
LEDON

\ UART
5 NTHBIT CONSTANT UART_OUTREADY_MASK
0 NTHBIT CONSTANT UART_INREADY_MASK

HEX
20200094 CONSTANT GPPUD
20200098 CONSTANT GPPUDCLK0
20215004 CONSTANT AUX_ENABLES
20215040 CONSTANT AUX_IO
20215054 CONSTANT AUX_LSR
20215044 CONSTANT AUX_IER
20215048 CONSTANT AUX_IIR
2021504C CONSTANT AUX_LCR
20215050 CONSTANT AUX_MCR 
20215058 CONSTANT AUX_MSR
20215060 CONSTANT AUX_CNTL
20215068 CONSTANT AUX_BAUD
DECIMAL

: SPIN 0 DO LOOP ; 
: UARTCLEAR 1 AUX_ENABLES ! 0 AUX_IER !  0 AUX_CNTL ! 3 AUX_LCR ! 0 AUX_MCR ! 0 AUX_IER ! 198 AUX_IIR ! 270 AUX_BAUD ! ;
: UARTGPIO GPFSEL1 @ 12 15 CLEARBITS 13 SETBIT 15 18 CLEARBITS 16 SETBIT GPFSEL1 ! ;
: UARTCLOCK 0 GPPUD ! 150 SPIN 14 NTHBIT 15 NTHBIT OR GPPUDCLK0 ! 150 SPIN 0 GPPUDCLK0 ! ;
: UARTINIT UARTCLEAR UARTGPIO UARTCLOCK 3 AUX_CNTL ! ;
: UARTOUTREADY AUX_LSR @ UART_OUTREADY_MASK AND 0<> ;
: UARTINREADY AUX_LSR @ UART_INREADY_MASK AND 0<> ;
: UARTRAWPUT AUX_IO ! ;
: UARTPUT BEGIN UARTOUTREADY UNTIL UARTRAWPUT ;
: UARTEMIT DUP '\n' = IF 13 UARTPUT THEN UARTPUT ;
: UARTGET AUX_IO @ 8BITMASK AND ;
: BREAK_TEST 3 = IF BREAK THEN ;
: UARTRAWKEY BEGIN UARTINREADY UNTIL UARTGET  ;
: UARTKEY UARTRAWKEY DUP 3 = IF BREAK THEN DUP 13 = IF DROP 10 THEN ;
UARTINIT

: ." IMMEDIATE ( -- )
	STATE @ IF
		[COMPILE] S" ' TELL ,
	ELSE
		BEGIN KEY DUP '"' = IF DROP EXIT THEN EMIT AGAIN
	THEN
;

\ Memory words
: C++ DUP C@ 1+ SWAP C! ;
: C-- DUP C@ 1- SWAP C! ;
: ++ DUP @ 1+ SWAP ! ;
: -- DUP @ 1- SWAP ! ;
: ->CELL 4 SWAP +! ;
: <-CELL 4 SWAP -! ;
: ->C 1 SWAP +! ;
: <-C 1 SWAP -! ;

\ Character constants
: BKSP 8 ;
: NL 10 ;
: '\t' 9 ;
: BL 32 ;
: CR 10 EMIT ;
: SPACE 32 EMIT ; 
: ISSPACE BL = ;
: SPACES ( n -- ) BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
: ZEROS ( n -- ) BEGIN DUP 0> WHILE '0' EMIT 1- REPEAT DROP ;


\ write out unsigned numbers
64 BUFFER  NUMPAD
63 NUMPAD + CONSTANT TOPPAD
: WRITECHAR TOPPAD C++ TOPPAD TOPPAD C@ - C! ;
: DIGIT DUP 10 >= IF 55 + WRITECHAR ELSE '0' + WRITECHAR THEN ;
: PUSHPAD TOPPAD TOPPAD C@ - TOPPAD C@ ;
: CLEARPAD 0 TOPPAD C! ;
: PDOT CLEARPAD BEGIN BASE @ /MOD SWAP DIGIT DUP 0= UNTIL DROP ;
: UDOT PDOT PUSHPAD ;
: DOT DUP 0< IF NEGATE PDOT '-' WRITECHAR ELSE PDOT THEN PUSHPAD ;
    
\ aligned unsigned
: U.R UDOT ROT OVER - SPACES TELL ;
: U.ZR UDOT ROT OVER - ZEROS TELL ;
: U. UDOT TELL BL EMIT ;

\ signed number output
: .R DOT ROT OVER - SPACES TELL ;
: . DOT TELL BL EMIT ;
: ? @ . ;
: .BIN BASE @ SWAP BINARY . BASE ! ;
: .HEX BASE @ SWAP HEX . BASE ! ;
: .OCTAL BASE @ SWAP OCTAL . BASE ! ;

\ Fixed point
: .INTEGER 16 RSHIFT DOT TELL  ;
: .FRACTIONAL 16BITMASK AND BEGIN 10 * DUP 16 RSHIFT '0' + EMIT 16BITMASK AND DUP 0= UNTIL ;
: .X DUP .INTEGER '.' EMIT .FRACTIONAL ;

\ Base switching words
: # ( b -- n ) BASE @ SWAP BASE ! WORD NUMBER DROP SWAP BASE ! ;
: 16# 16 # ;
: 10# 10 # ;
: 2# 2 # ;
: 8# 8 # ;
: BINARY ( -- ) 2 BASE ! ;
: OCTAL ( -- ) 8 BASE ! ;

\ standard words
: ON TRUE SWAP ! ;
: OFF FALSE SWAP ! ;
: MAX 2DUP > IF DROP ELSE SWAP DROP THEN ;
: MIN 2DUP <= IF DROP ELSE SWAP DROP THEN ;
: CLIP ( c a b -- c ) ROT MIN MAX ;
: ABS DUP 0< IF NEGATE THEN ;
: WITHIN -ROT OVER <= IF > IF TRUE ELSE FALSE THEN ELSE 2DROP FALSE THEN ;
: ISLOWERALPHA ( c -- ok ) DUP 'a' >= SWAP 'z' <= AND ;
: ISLETTER DUP ISALPHA SWAP ISLOWERALPHA OR ;
: DEPTH DSP@ S0 @ - 2 RSHIFT ;
: NALIGNED ( val n -- val_aligned ) 1 SWAP LSHIFT 1- DUP ROT + SWAP INVERT AND ; 
: NALIGN ( n -- ) HERE @ SWAP NALIGNED HERE ! ;
: BUFFER ALLOT CONSTANT ;
: 2OVER 3 PICK 3 PICK ;
: 2SWAP >R -ROT R> -ROT ;
: TUCK SWAP OVER ;
: VARIABLE: VARIABLE LATEST @ >CFA EXECUTE ! ;
: RECURSE IMMEDIATE LATEST @ >CFA , ;

\ Private namespaces
VARIABLE HIDDEN_BLOCK
VARIABLE REVEAL_BLOCK
: +HIDDEN 4+ DUP C@ F_HIDDEN OR SWAP C! ;
: {{ LATEST @ HIDDEN_BLOCK ! 0 REVEAL_BLOCK ! ;
: PUBLIC: LATEST @ REVEAL_BLOCK ! ;
: }} REVEAL_BLOCK @ DUP 0= IF DROP LATEST THEN BEGIN @ DUP +HIDDEN DUP HIDDEN_BLOCK @ = UNTIL DROP ;


\ stack printing
{{
    VARIABLE TSP
    : +TSP -4 TSP +! ;
    : TSP@ TSP @ @ ;
    : SETTSP S0 @ 4 - TSP ! ;
PUBLIC:
    : .S SETTSP BEGIN TSP @ DSP@ 4 + >= IF TSP@ . +TSP FALSE ELSE TRUE THEN UNTIL ; 
    : .R RSP@ BEGIN DUP R0 <= IF ." 0x" DUP @ .HEX 4+ FALSE ELSE TRUE THEN UNTIL DROP ;
}}


\ quotations

\ space to store quotations
16000 ALLOT CONSTANT QUOTEBLOCK
QUOTEBLOCK VARIABLE: QUOTEHERE
\ recursive quotes don't work :(
: [ IMMEDIATE QUOTEHERE @ STATE @ IF ' LIT , , THEN STATE @ HERE @ QUOTEHERE @ HERE ! DOCOL , ]] ;
: ] IMMEDIATE LIT EXIT , HERE @ QUOTEHERE ! HERE ! STATE ! ;
: QIF IF NIP EXECUTE ELSE DROP EXECUTE THEN ;
: QIFTRUE IF EXECUTE ELSE DROP THEN ;
: QIFFALSE IF DROP ELSE EXECUTE THEN ;
: QWHILE >R BEGIN R> DUP >R EXECUTE INVERT UNTIL R> DROP ; 
: QUNTIL >R BEGIN R> DUP >R EXECUTE UNTIL R> DROP ; 
\ : QTIMES >R 0 DO R> DUP >R EXECUTE LOOP R> DROP ;
\ : ITER >R 0 DO R> DUP >R I EXECUTE LOOP R> DROP ;
\ : ITERD >R >R  BEGIN R> DUP >R EXECUTE  R> R> 1- -ROT >R >R 0= UNTIL R> R> DROP DROP ; 
: QPRESERVE DUP >R @ >R  EXECUTE R> R> SWAP ! ;
: QDIP >R EXECUTE R> ;
: QSIP DUP >R EXECUTE R> ;


\ Original JONESFORTH introspection functions        
: COUNT DUP 1+ SWAP C@  ;
: ID. 4+ COUNT F_LENMASK AND BEGIN DUP 0> WHILE SWAP COUNT EMIT SWAP 1- REPEAT 2DROP ;
: >DFA >CFA 4+ ;
: DICT WORD FIND ;
: VALUE ( n -- ) WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
: TO IMMEDIATE ( n -- )
        DICT >DFA 4+
	STATE @ IF ' LIT , , ' ! , ELSE ! THEN
;
: +TO IMMEDIATE
        DICT >DFA 4+
	STATE @ IF ' LIT , , ' +! , ELSE +! THEN
;

: ?HIDDEN 4+ C@ F_HIDDEN AND ;
: ?IMMEDIATE 4+ C@ F_IMMED AND ;
: WORDS LATEST @ BEGIN ?DUP WHILE DUP ?HIDDEN NOT IF DUP ID. SPACE ." 0x" DUP . CR THEN @ REPEAT CR ;
: FORGET DICT DUP @ LATEST ! HERE ! ;
: CFA> LATEST @ BEGIN ?DUP WHILE 2DUP SWAP < IF NIP EXIT THEN @ REPEAT DROP 0 ;
: WORDEXTENTS ( wordptr -- end start )  HERE @ LATEST @
	BEGIN 2 PICK OVER <> WHILE NIP DUP @ REPEAT
	DROP SWAP ;
    
: SEE
	DICT DUP 0= IF ." Word not found" CR EXIT THEN WORDEXTENTS  ':' EMIT SPACE DUP ID. SPACE
	DUP ?IMMEDIATE IF ." IMMEDIATE " THEN
	>DFA BEGIN 2DUP
        > WHILE DUP @ CASE
		' LIT OF 4 + DUP @ . ENDOF
		' LITS OF [[ CHAR S ]] LITERAL EMIT '"' EMIT SPACE
			4 + DUP @ SWAP 4 + SWAP 2DUP TELL '"' EMIT SPACE + ALIGNED 4 -
		ENDOF
		' 0BRANCH OF ." 0BRANCH ( " 4 + DUP @ . ." ) " ENDOF
		' BRANCH OF ." BRANCH ( " 4 + DUP @ . ." ) " ENDOF
		' ' OF [[ CHAR ' ]] LITERAL EMIT SPACE 4 + DUP @ CFA> ID. SPACE ENDOF
		' EXIT OF 2DUP 4 + <> IF ." EXIT " THEN ENDOF
		DUP CFA> ID. SPACE
	ENDCASE 4 + REPEAT
	';' EMIT CR 2DROP
;
: :NONAME 0 0 CREATE HERE @ DOCOL , ]] ;
: ['] IMMEDIATE ' LIT , ;


\ compile a word by expanding it in place
\ : EXPAND IMMEDIATE STATE @ IF HERE 4- @ WORDEXTENTS HERE @ HERE 4- ! BEGIN DUP @ , 4+ 2DUP = UNTIL THEN ;

\ Exception handling
: EXCEPTION-MARKER R> DROP 0 ;
: CATCH ( xt -- exn? ) DSP@ 4+ >R ' EXCEPTION-MARKER 4+ >R EXECUTE ;
: THROW ( n -- ) ?DUP IF
	RSP@ BEGIN DUP R0 4-
        < WHILE DUP @ ' EXCEPTION-MARKER 4+
		= IF 4+ RSP! DUP DUP DUP R> 4- SWAP OVER ! DSP! EXIT THEN
	4+ REPEAT DROP
	CASE
		0 1- OF ." ABORTED" CR ENDOF
		." UNCAUGHT THROW " DUP . CR
	ENDCASE QUIT THEN
;
: ABORT ( -- ) 0 1- THROW ;
: PRINT-STACK-TRACE
	RSP@ BEGIN DUP R0 4-
        < WHILE DUP @ CASE
		' EXCEPTION-MARKER 4+ OF ." CATCH ( DSP=" 4+ DUP @ U. ." ) " ENDOF
		DUP CFA> ?DUP IF 2DUP ID. [[ CHAR + ]] LITERAL EMIT SWAP >DFA 4+ - . THEN
	ENDCASE 4+ REPEAT DROP CR
;
: UNUSED ( -- n ) PAD HERE @ - 4/ ;



\ Hex dumping of memory

{{
    : BAR [[ CHAR | ]] LITERAL EMIT ; 
    : HEX_ADDRESS DUP 8 SWAP U.ZR  ;
    : HD DUP C@ 2 SWAP U.ZR 1+ SPACE ;
    : HEX_ROW HD HD HD HD HD HD HD HD ;
    : PRINTABLE_CHAR DUP 32 < IF DROP '.' THEN DUP 127 > IF DROP '.' THEN ;
    : AS DUP C@ PRINTABLE_CHAR EMIT 1+ ; 
    : 4AS AS AS AS AS ;
    : ASCII_ROW 4AS 4AS 4AS 4AS ;
PUBLIC:
    : DUMP ( addr len -- ) DUP 4096 > IF DROP 4096 THEN 
        BASE @ -ROT HEX  \ store old base and switch to hex
        BEGIN SWAP HEX_ADDRESS 2 SPACES HEX_ROW SPACE HEX_ROW 2 SPACES 
        16 - BAR ASCII_ROW BAR CR SWAP 16 - DUP 0<= UNTIL \ until done
        CR 2DROP BASE ! ;
}}

\ Counted loops
32 CELLS ALLOT VARIABLE: LOOPSP
LOOPSP @ CONSTANT LOOPTOP
: >LOOP LOOPSP @ ! LOOPSP ->CELL ;
: LOOP> LOOPSP <-CELL LOOPSP @ @ ; 
: DO IMMEDIATE ' >LOOP , ' >LOOP , [COMPILE] BEGIN ;
: LOOPCHECK LOOP> LOOP> 1+  2DUP =  -ROT >LOOP >LOOP ;
: +LOOPCHECK LOOP> LOOP> ROT + 2DUP <=  -ROT >LOOP >LOOP ;
: LOOPFINISH LOOP> DROP LOOP> DROP ;
: LOOP IMMEDIATE ' LOOPCHECK , [COMPILE] UNTIL ' LOOPFINISH , ;
: +LOOP IMMEDIATE ' +LOOPCHECK , [COMPILE] UNTIL ' LOOPFINISH , ;
: I LOOPTOP @  ;
: J LOOPTOP 8 + @  ;

\ append a character to a string on the stack; must be enough room in the buffer
: SUFFIX 1+ SWAP OVER + ROT SWAP -ROT C! SWAP ;


\ basic linked list/stack
: LIST.MK 2 CELLS ALLOT DUP 4+ 0 ! ( -- listptr[val,ptr] ) ;
: LIST.NIL 0 ;
: LIST.CONS ( car cdr -- cons ) SWAP LIST.MK DUP -ROT ! DUP ROT SWAP 4+ ! ;
: LIST.CDR ( listptr -- listptr ) 4+ @ ;
: LIST.CAR ( listptr -- val ) @ ;
: LIST.NTH ( listptr n -- val ) 0 DO LIST.CDR LOOP LIST.CAR ;

: LIST.PUSH BEGIN DUP LIST.CAR SWAP LIST.CDR DUP 0= UNTIL DROP ;
: LIST.CREATE ( n1 n2 n3 n4 ... n -- listptr )  LIST.NIL SWAP 0 DO LIST.CONS LOOP ;
: LIST.MAPCAR >R BEGIN DUP LIST.CAR R> DUP >R EXECUTE DUP LIST.CDR 0= IF DROP TRUE ELSE LIST.CDR FALSE THEN UNTIL R> DROP ;
: LIST.PRINT ['] . LIST.MAPCAR ;
VARIABLE LIST.FILTERED
: LIST.FILTER NIL LIST.FILTERED ! >R BEGIN DUP LIST.CAR DUP R> DUP >R EXECUTE IF LIST.FILTERED @ CONS LIST.FILTERED ! ELSE DROP THEN DUP LIST.CDR 0= IF DROP TRUE ELSE LIST.CDR FALSE THEN UNTIL R> DROP ;

VARIABLE LIST.PRODUCT
: LIST.REDUCE >R DUP LIST.CAR LIST.PRODUCT ! LIST.CDR BEGIN DUP LIST.CAR LIST.PRODUCT @ R> DUP >R EXECUTE LIST.PRODUCT ! DUP LIST.CDR 0= IF DROP TRUE ELSE LIST.CDR FALSE THEN UNTIL R> DROP LIST.PRODUCT @ ;

: LIST.LAST BEGIN DUP LIST.CDR 0<> WHILE LIST.CDR REPEAT ;
: LIST.MAKE_ENDLESS DUP DUP LIST.LAST 4+ ! ;

: TESTLIST 1 2 3 4 5 5 LIST.CREATE ;

\ ANSI codes

27 CONSTANT ESC
: '~' [[ CHAR ~ ]] LITERAL ;
: '[' [[ CHAR [ ]] LITERAL ;
: 'm' [[ CHAR m ]] LITERAL ;
: '2' [[ CHAR 2 ]] LITERAL ;
: 'J' [[ CHAR j ]] LITERAL ;
: ANSICOLOR ESC EMIT '[' EMIT DOT TELL 'm' EMIT ;
VARIABLE ANSI_FG_SET
VARIABLE ANSI_BG_SET
: ANSI_FG 30 + DUP ANSI_FG_SET ! ANSICOLOR ;
: ANSI_BG 40 + DUP ANSI_BG_SET ! ANSICOLOR ;
: ANSI_ATTR ANSI_BG ANSI_FG ;
0 CONSTANT ANSI_BLACK
1 CONSTANT ANSI_RED
2 CONSTANT ANSI_GREEN
3 CONSTANT ANSI_YELLOW
4 CONSTANT ANSI_BLUE
5 CONSTANT ANSI_MAGENTA
6 CONSTANT ANSI_CYAN
7 CONSTANT ANSI_WHITE
0 CONSTANT ANSI_PLAIN
1 CONSTANT ANSI_BOLD
4 CONSTANT ANSI_UNDERSCORE
5 CONSTANT ANSI_BLINK
7 CONSTANT ANSI_REVERSE
8 CONSTANT ANSI_CONCEALED
: ANSI_CLS ESC EMIT S" [2J" TELL ;
: ANSI_CLRLINE ESC EMIT S" [K" TELL ;
: ANSI_DEFAULT 37 ANSICOLOR 40 ANSICOLOR ;
: ANSI_ERROR ANSI_BLACK ANSI_BG ANSI_RED ANSI_FG ;


\ System functions

\ Timer access
{{
    16# 2000B400 CONSTANT TIMER_BASE
    TIMER_BASE 16# 8 + CONSTANT TIMER_CTL
    TIMER_BASE 16# 20 + CONSTANT TIMER_CNT
    16# 00F90000 CONSTANT TIMER_ENABLE
    16# 00F90200 CONSTANT TIMER_SET
    0 VARIABLE: WAIT_ADJUSTMENT
    VARIABLE TIMEITVAR
    VARIABLE TIMEIT_OVERHEAD
PUBLIC:    
    : TIMER_INIT TIMER_ENABLE TIMER_CTL ! TIMER_SET TIMER_CTL ! ;
    : TIMER_READ TIMER_CNT @ ;
    : TIMER_WAIT ( usecs -- ) TIMER_READ +  WAIT_ADJUSTMENT @ - BEGIN DUP TIMER_READ < UNTIL DROP ;
    : TIMER_SECONDS TIMER_READ 1000000 / ;    
    \ Profile run time of a word: e.g. 200 30 RUNTIME + 
    \ compute the call overhead 
    : CALC_OVERHEAD TIMER_READ TIMEITVAR ! TIMER_READ TIMEITVAR @ - TIMEIT_OVERHEAD ! ;
    CALC_OVERHEAD FORGET CALC_OVERHEAD
    : RUNTIME WORD FIND >CFA TIMER_READ TIMEITVAR ! EXECUTE TIMER_READ TIMEITVAR @ - TIMEIT_OVERHEAD @ - ;
    \ adjust the timer waiting
    200 RUNTIME TIMER_WAIT 200 - WAIT_ADJUSTMENT !
    : TIMEIT RUNTIME . ." uS" ;
}}


\ Load a hex block from the stream. Terminate with non-number
{{
    16# 100000 CONSTANT UPLOAD_ADDRESS
    VARIABLE BOOT_ADDRESS
    : HEXLOAD HEX BEGIN DUP WORD NUMBER 0= IF SWAP C! 1+ FALSE ELSE DROP TRUE THEN UNTIL ;
PUBLIC:
    : UPLOAD ." Start hex transfer:" CR HEX UPLOAD_ADDRESS HEXLOAD ." OK: 0x" UPLOAD_ADDRESS - . ." bytes transferred." CR ;
    : BOOT UPLOAD_ADDRESS BOOT_ADDRESS ! BOOT_ADDRESS EXECUTE ;
}}

\ quote that works in immediate mode
: QUOTE WORD FIND >CFA ( -- xt ) ;
: BACKPATCH QUOTE QUOTE 4+ ! ;




: UARTIN_TIMEOUT TIMER_READ + BEGIN UARTINREADY IF UARTGET EXIT ELSE DUP TIMER_READ < IF -1 EXIT THEN THEN AGAIN ;


{{    
    16# 4 CONSTANT X_EOT
    16# 1 CONSTANT X_SOH
    16# 6 CONSTANT X_ACK
    16# 15 CONSTANT X_NAK
    16# 18 CONSTANT X_CAN 
    
    : SOH X_SOH UARTEMIT ;
    : EOT X_EOT UARTEMIT ;
    : ACK X_ACK UARTEMIT ;
    : NAK X_NAK UARTEMIT ;
    : CAN X_CAN UARTEMIT ;    
    
    : WAITCHAR 250000 UARTIN_TIMEOUT ;
    : XMODEM_FLUSH BEGIN WAITCHAR -1 = UNTIL ;
    
    VARIABLE RCV_LIMIT 
    VARIABLE RCV_ADDR 
    VARIABLE RCV_LEN
    VARIABLE BLK
    VARIABLE ERRCOUNT
    0 VARIABLE: RCV_DONE
    : SECS 1000000 * ;
    
    : XMODEM_CANCEL CAN CAN CAN ;
    VARIABLE CHKSUM
    : RCV_BYTES  0 DO WAITCHAR DUP CHKSUM +! OVER C! 1+ LOOP  ;
    : XMODEM_BLKNO WAITCHAR BLK @ <> IF FALSE EXIT THEN WAITCHAR 255 BLK @ - <> IF FALSE EXIT THEN TRUE ;
    : XMODEM_NEXT 128 RCV_ADDR +! 1 BLK +! 128 RCV_LEN +! ;
    : XMODEM_BLOCK XMODEM_BLKNO NOT IF FALSE EXIT THEN 0 CHKSUM ! RCV_ADDR 128 RCV_BYTES WAITCHAR CHKSUM @ <> IF FALSE EXIT THEN XMODEM_NEXT TRUE ;    
    : XMODEM_ERROR XMODEM_FLUSH NAK ERRCOUNT ++ ;
    : XMODEM_HEADER BEGIN 
        ERRCOUNT @ 10 > IF XMODEM_CANCEL -1 RCV_LEN ! EXIT THEN ( break on too many errors )        
        XMODEM_ERROR 3 SECS UARTIN_TIMEOUT DUP ( NAK every 3 seconds ) 
        X_EOT = IF ACK DROP EXIT ELSE  ( check if done )
        X_SOH = IF XMODEM_BLOCK IF ACK ELSE XMODEM_ERROR THEN ELSE XMODEM_ERROR THEN ( if data, read it )
        AGAIN ;
PUBLIC:
    : XMODEM_RCV ( addr max -- ) 0 ERRCOUNT ! RCV_LIMIT ! RCV_ADDR ! 0 RCV_LEN ! XMODEM_HEADER RCV_LEN @ ;
    : XMODEM_RECV ." Begin XMODEM transfer" CR XMODEM_RCV DUP -1 = IF ." Transfer failed!" CR ELSE ." Transfer succeeded; " DUP . ." bytes transfered" CR THEN ;
}}    




\ allow input redirection by redefining INPUT-STREAM
\ INPUT-STREAM points at a word that retrieves one more character from the input
\ OUTPUT-STREAM points at a word that outputs a single character
VARIABLE INPUT-STREAM QUOTE MEMKEY INPUT-STREAM !
VARIABLE OUTPUT-STREAM QUOTE UARTEMIT OUTPUT-STREAM !
: NKEY INPUT-STREAM @ EXECUTE ; 
: NEMIT OUTPUT-STREAM @ EXECUTE ;
BACKPATCH NKEY KEY
BACKPATCH NEMIT EMIT


\ rewrite WORD to use the new KEY function
: APPEND ( c addr -- ) DUP C++ DUP C@ + C! ;
: DELETE ( addr -- ) DUP C@ 0> IF C-- THEN ;
: CLEARSTR 0 SWAP C! ;
: PUSHSTR DUP C@ SWAP 1+ SWAP ;
: LENSTR C@ ;
: CMP 2DUP = IF 0 ELSE > IF -1 ELSE 1 THEN THEN ;
: CMPCHAR DUP C@ 2 PICK C@ CMP ;
: 3DROP DROP DROP DROP ;
: CMPSTR ( addr1 l1 addr2 l2 -- cmp ) ROT MIN BEGIN -ROT CMPCHAR DUP 0< IF 3DROP -1 EXIT THEN 0> IF 3DROP 1 EXIT THEN 
  ROT DUP 0= SWAP 1- SWAP UNTIL 3DROP 0 ;
: STRCMP PUSHSTR ROT PUSHSTR CMPSTR ;
: TELLSTR PUSHSTR TELL ;
: ISBLANK DUP BL = OVER '\n' = OR OVER '\t' = OR NIP ;
: SKIPSPACE BEGIN KEY DUP ISBLANK NOT UNTIL ;
32 ALLOT CONSTANT WORDBUFFER# 
WORDBUFFER# 1+ CONSTANT WORDBUFFER
: NWORD
  WORDBUFFER# CLEARSTR
  KEY DUP ISBLANK IF DROP SKIPSPACE THEN  
  WORDBUFFER# APPEND  
  BEGIN KEY DUP ISBLANK IF DROP TRUE ELSE WORDBUFFER# APPEND FALSE THEN UNTIL
  WORDBUFFER# PUSHSTR 
;

( backpatch word to actually execute nword )
BACKPATCH NWORD WORD



\ 16 CONSTANT HISTORY_LINES
\ VARIABLE HISTORY_PTR 
\ : ALLOCATE_HISTORY_LINE 256 ALLOT ;
\ 4 CONSTANT HISTORY_LINES
\ HERE @ CONSTANT HISTORY_START ALLOCATE_HISTORY_LINE ALLOCATE_HISTORY_LINE ALLOCATE_HISTORY_LINE ALLOCATE_HISTORY_LINE
\ make loop here
\ : NEXT_HISTORY HISTORY_PTR 1+ DUP > HISTORY_LINES IF 0 THEN HISTORY_PTR ! ;
\ : PREV_HISTORY HISTORY_PTR 1- DUP < 0 IF HISTORY_LINES 1- THEN HISTORY_PTR ! ;
\ : HISTORY_BUF HISTORY_PTR @ 8 LSHIFT HISTORY_START +
\ : COPY_HISTORY HISTORY_BUF TIB# 256 CMOVE ;
\ : PUSH_HISTORY TIB# HISTORY_BUF 256 CMOVE ;


256 BUFFER TIB#
TIB# 1+ CONSTANT TIB
VARIABLE TIB_CURSOR 
VARIABLE ESCAPE_STATE 
0 ESCAPE_STATE !

VARIABLE >IN 0 >IN !
: CLEAR_TIB 0 TIB# C! 0 TIB_CURSOR ! 0 >IN ! ; 
: ECHO UARTKEY DUP EMIT ;
: CURSOR_LEFT TIB_CURSOR C-- ;
: CURSOR_RIGHT TIB_CURSOR C++ ;
: BACKSPACE TIB# C@ 0> IF TIB# C-- CURSOR_LEFT ELSE 0 TIB# C! THEN ;
: WRITE_CHAR TIB# APPEND CURSOR_RIGHT ;

: NORMAL_CHAR DUP CASE 
    ( not in an escape sequence )
    BKSP OF EMIT BACKSPACE ENDOF 
    ESC OF DROP 1 ESCAPE_STATE !  ENDOF    
    ( -- default ) DUP EMIT WRITE_CHAR 
    ENDCASE ;

\ control characters are of the form  'ESC' '[' [value[;value]] <char>
    
\ buffer for ansi value field    
32 BUFFER ESCAPE_BUF



VARIABLE TABPTR
: RESET_TAB LATEST @ TABPTR ! ;
\ find first space character, moving rightwards
: FIND_PREFIX TIB# C@ 1+ BEGIN 1- DUP TIB# + 1+ C@ ISBLANK OVER 0<= OR UNTIL DUP TIB# + SWAP TIB# C@ SWAP - ;
: HANDLE_CURSOR 'A' = IF 'A' CURSOR_LEFT ESC EMIT '[' EMIT 'A' EMIT ELSE DROP THEN ;
: CLEAR_ESCAPE 0 ESCAPE_STATE ! ;
: TEST_ESCAPE DUP '[' = IF 2 ESCAPE_STATE ! ESCAPE_BUF CLEARSTR DROP ELSE CLEAR_ESCAPE NORMAL_CHAR THEN ;
: ANSI_ESCAPE DUP ISLETTER OVER '~' = OR  IF HANDLE_CURSOR CLEAR_ESCAPE ELSE ESCAPE_BUF APPEND THEN ;
: ESCAPE_CHAR ESCAPE_STATE @ 2 = IF ANSI_ESCAPE ELSE TEST_ESCAPE THEN ;  
               
: IN_CHAR ESCAPE_STATE @ 0= IF NORMAL_CHAR ELSE ESCAPE_CHAR THEN ;
: ACCEPT CLEAR_TIB BEGIN UARTKEY DUP IN_CHAR OVER = UNTIL DROP ;
: READ_LINE NL ACCEPT ;

: CHARAT ( addr ix -- c) + 1+ C@ ;
: LINE_FLUSH_IN CLEAR_TIB ;




: FLUSH_IN . ; \ backpatch this later
: FLUSH_OUT . ; \ backpatch this later


( make line buffered input the outer interpreter )
: LINE_KEY
    ( get some characters )
    TIB# LENSTR 0=  IF BEGIN READ_LINE TIB# LENSTR 0<> UNTIL 0 >IN ! THEN
    TIB# >IN @ CHARAT >IN @ 1+ >IN !
    ( clear buffer at end of line )
    >IN @ TIB# LENSTR >= IF CLEAR_TIB THEN 
;

\ left, right
\ home, end
\ ins/over
\ up/down buffer
\ tab completion



: STATUS  ." HERE:0x" HERE @ .HEX  ." LATEST:0x" LATEST @ .HEX  2 SPACES ." R0:0x" R0 .HEX  ." RSP:0x" RSP@ .HEX 2 SPACES ." DSP:0x" DSP@ .HEX  ." S0:0x" S0 @ .HEX  CR ;

: WELCOME ANSI_BLUE ANSI_BG ANSI_CLS ANSI_YELLOW ANSI_FG
S"                                                      
                       ____    _____   ____    ______  __  __
            __        /\  _`\ /\  __`\/\  _`\ /\__  _\/\ \/\ \
   ___ ___ /\_\    ___\ \ \L\_\ \ \/\ \ \ \L\ \/_/\ \/\ \ \_\ \
 /' __` __`\/\ \ /' _ `\ \  _\/\ \ \ \ \ \ ,  /  \ \ \ \ \  _  \
 /\ \/\ \/\ \ \ \/\ \/\ \ \ \/  \ \ \_\ \ \ \\ \  \ \ \ \ \ \ \ \
 \ \_\ \_\ \_\ \_\ \_\ \_\ \_\   \ \_____\ \_\ \_\ \ \_\ \ \_\ \_\
  \/_/\/_/\/_/\/_/\/_/\/_/\/_/    \/_____/\/_/\/ /  \/_/  \/_/\/_/
" TELL CR
." 0x" UNUSED . ." CELLS FREE" 
CR STATUS

CR ." READY"
CR
DECIMAL
;




    
\ experimental stuff

( signed division )


\ heap manipulation
\ | SIZE | PREV | NEXT | REFC | TYPE |
: H->SIZE 0 ;
: H->PREV 4 + ;
: H->NEXT 8 +  ;
: H->REFC 12 + ;
: H->TYPE 16 +  ;

20 CONSTANT HEADER_SIZE
PAD 128 + CONSTANT HEAP_START
16# 1000000 CONSTANT HEAP_SIZE
HEAP_SIZE VARIABLE: HEAP_AVAILABLE
: !-> SWAP DUP -ROT ! 4+ ; 
: INIT_HEAP HEAP_START HEAP_SIZE !-> 0 !-> 0 !-> 0 !-> 0 !-> DROP ;
: BLOCKFITS DUP H->TYPE @ 0= OVER H->SIZE @ > AND ;
: BLOCKNEXT DUP H->NEXT @ 0= IF ." Memory exhausted" ABORT THEN ;
\ : NEWBLOCK ( n ptr -- ) OVER HEADER_SIZE + SIZE @ !-> PREV @ !-> NEXT @ 0 !-> 0 !-> ;
\ : FINDFREE ( n -- ptr ) HEAP_START BLOCKFITS NOT IF BEGIN BLOCKNEXT BLOCKFITS UNTIL  ;
: FREE ( ptr -- ) ;
: REALLOC ( n -- ptr ) ;

: S/MOD 
TUCK DUP 0<
IF NEGATE TRUE ELSE FALSE THEN 
ROT
DUP 0< IF NEGATE -ROT INVERT ELSE -ROT THEN -ROT /MOD ROT
IF NEGATE 1- SWAP ROT SWAP - ELSE ROT DROP THEN ;





: LOOPTEST 5 0 DO I . LOOP ;
: IJLOOPTEST 5 0 DO 10 0 DO I . J . LOOP LOOP ;
: +LOOPTEST 50 0 DO I . 5 +LOOP ;


\ Framebuffer access (preliminary)
: MKSTRUCT  HERE @ CONSTANT ;
: DW 1 CELLS ALLOT CONSTANT ;

4 NALIGN
MKSTRUCT FRAMEBUFFER
DW FB_PHYSICAL_WIDTH
DW FB_PHYSICAL_HEIGHT
DW FB_VIRTUAL_WIDTH
DW FB_VIRTUAL_HEIGHT
DW FB_PITCH
DW FB_BIT_DEPTH
DW FB_X
DW FB_Y
DW FB_PTR
DW FB_SIZE

30 NTHBIT CONSTANT BIT30

16# 2000B880 CONSTANT MAILREAD_ADDR
16# 2000B890 CONSTANT MAILPOLL_ADDR
16# 2000B894 CONSTANT MAILSENDER_ADDR
16# 2000B898 CONSTANT MAILSTATUS_ADDR
16# 2000B89C CONSTANT MAILCONFIG_ADDR
16# 2000B89C CONSTANT MAILWRITE_ADDR

: MAILWAIT_STATUS BEGIN MAILSTATUS_ADDR @ BIT30 AND 0= UNTIL ; 
: LOW4BITS 2# 1111 AND ;
: MAILREAD ( mbox ) LOW4BITS BEGIN MAILWAIT_STATUS DUP MAILREAD_ADDR @ XOR DUP LOW4BITS 0= UNTIL 4 RSHIFT ;
: MAILWRITE ( msg mbox -- ) MAILWAIT_STATUS SWAP 4 LSHIFT OR MAILWRITE_ADDR ! ;

: MAPCHAR NEXTCHAR 3 PICK EXECUTE ROT DUP -ROT 1- C! SWAP ( xt addr len -- xt addr+1 len-1 ) ; 
: MAPSTR 2 PICK 2 PICK BEGIN MAPCHAR DUP 0= UNTIL DROP DROP DROP ( addr len xt -- addr len ) ;
: +13 13 + ;
: ROT13 QUOTE +13 MAPSTR ;

( N D Q R )
VARIABLE DIVD
VARIABLE DIVN

: DIVSTEP RSHIFT DIVN @  1 AND OR DUP 4 PICK >= IF 2 PICK - SWAP 1 OR SWAP THEN ;
: DIVI 
    DIVN ! DIVD !
    DIVD @ 0= IF ." Divide by zero" ABORT THEN
    0 0
    
    DIVSTEP   
;

\ redirect input

CLEAR_TIB LEDOFF WELCOME 
\ Everything after this line will not be seen!
QUOTE LINE_KEY INPUT-STREAM !



\ ARM opcodes

\ 0 VARIABLE OPC
\ : ENUM 0 OPC ! BEGIN OPC @ CONSTANT OPC 1 +! 1- 0= UNTIL ;
: ENUM{ BEGIN WORD 2DUP DROP C@ '}' <> WHILE REPEAT ;
\ 16 ENUM{ EQ NE CS CC MI PL VS VC HI LS GE LT GT LE AL UNC }
\ data processing opcodes
\ 16 ENUM{ AND EOR SUB RSB ADD ADC SBC RSC TST TEQ CMP CMN ORR MOV BIC MVN }

\ EQ R4 45 # 2 LSL ORR;
\ R4 R0 2 ROR MOV;


\ VARIABLE ASM.COND
\ VARIABLE ASM.SHIFTER
\ VARIABLE ASM.Rn
\ VARIABLE ASM.Rd
\ VARIABLE ASM.#




\ TODO
\ line editor
\ ?do / LEAVE / UNLOOP
\ clear / cmove / fill / blank
\ make word names indirect : | FLAGS | STRPTR | CFA | | CODE ...
\ namespaces
\ debugger
\ toupper / tolower
\ strcompare
\ make quotations work in compile mode
\ mmc
\ xmodem transfer
\ signed division
\ inline / code
\ locals
\ framebuffer
\ fixed point: */ .FX / SIN.COS / SQRT / EXP
\ live syntax highlighting / tab completion
\ alloc / free / resize
\ structs, lists
\ inline / unthread / unthread-fully / denext





